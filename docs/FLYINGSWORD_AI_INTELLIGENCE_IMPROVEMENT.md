# é£å‰‘AIæ™ºèƒ½è¡¨ç°æ”¹è¿›æ–¹æ¡ˆ

> **æ ¸å¿ƒç†å¿µ**ï¼šç”¨ç®€å•ã€å¯é¢„æµ‹çš„é€»è¾‘åˆ›é€ "çœ‹èµ·æ¥èªæ˜"çš„è¡Œä¸ºï¼Œè€Œä¸æ˜¯å †ç Œå¤æ‚ä»£ç 

## é—®é¢˜è¯Šæ–­ ğŸ”

### å½“å‰ç³»ç»Ÿçš„"å‡å¤æ‚"

**ä»£ç å¤æ‚åº¦**ï¼š
- 16 ä¸ª Intent ç±»ï¼ˆè®¸å¤šåªæœ‰ 6-20 è¡Œé€»è¾‘ï¼‰
- 17 ç§è½¨è¿¹ç±»å‹
- 575 è¡Œçš„ TargetFinderï¼ˆ8 ä¸ªä¸“ç”¨æ–¹æ³•ï¼‰
- HUNT æ¨¡å¼è¿˜åœ¨ç”¨æ—§çš„ HuntBehaviorï¼ˆæœªå®Œæˆè¿ç§»ï¼‰

**å®é™…æ•ˆæœ**ï¼š
- âŒ **ä¸èªæ˜**ï¼šä¼˜å…ˆçº§å…¬å¼æ˜¯ç¡¬ç¼–ç çš„é­”æ³•æ•°å­—ï¼ˆä¸ºä»€ä¹ˆ Duel æ˜¯ 18 ä½† Shepherd æ˜¯ 11ï¼Ÿï¼‰
- âŒ **æ€§èƒ½å·®**ï¼šæ¯å¸§é‡å¤æœç´¢ç›¸åŒç›®æ ‡ï¼ˆAssassinIntent æ‰¾æœ€ä½è¡€é‡ï¼ŒFocusFireIntent ä¹Ÿæ‰¾æœ€ä½è¡€é‡ï¼‰
- âŒ **éš¾è°ƒè¯•**ï¼šæ²¡æœ‰å†³ç­–æ—¥å¿—ï¼Œæ— æ³•ç†è§£ä¸ºä»€ä¹ˆé£å‰‘é€‰æ‹©æŸä¸ªè¡Œä¸º
- âŒ **ä¸åä½œ**ï¼šAIContext åªæœ‰ 4 ä¸ªå­—æ®µï¼ŒIntent æ— æ³•å…±äº«ä¿¡æ¯

### "èªæ˜"åº”è¯¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ

**ç©å®¶çœ¼ä¸­çš„"æ™ºèƒ½é£å‰‘"**ï¼š
1. **æƒ…å¢ƒæ„ŸçŸ¥**ï¼šè¢«å›´æ”»æ—¶æ•£å¼€ï¼Œè¿½å‡»æ—¶é›†ä¸­
2. **é¢„åˆ¤æ•Œäºº**ï¼šæ‹¦æˆªç§»åŠ¨ç›®æ ‡ï¼Œä¼˜å…ˆå¨èƒå•ä½
3. **åä½œé…åˆ**ï¼šå¤šæŠŠå‰‘åˆ†å·¥æ˜ç¡®ï¼ˆæœ‰çš„ç¼ æ–—ï¼Œæœ‰çš„çªè¢­ï¼‰
4. **æµç•…è¿‡æ¸¡**ï¼šè¡Œä¸ºåˆ‡æ¢è‡ªç„¶ï¼Œä¸ä¼š"æŠ½é£å¼"è½¬å‘
5. **è®°å¿†ä¸å­¦ä¹ **ï¼šä¸ä¼šåå¤æ”»å‡»æ— æ³•ä¼¤å®³çš„ç›®æ ‡

**å…³é”®æ´å¯Ÿ**ï¼šè¿™äº›è¡¨ç°ä¸éœ€è¦å¤æ‚é€»è¾‘ï¼Œéœ€è¦çš„æ˜¯**æ­£ç¡®çš„æŠ½è±¡å±‚**ï¼

---

## æ”¹è¿›æ–¹æ¡ˆ ğŸš€

### æ–¹æ¡ˆ Aï¼šæ•ˆç”¨AIç³»ç»Ÿï¼ˆUtility AIï¼‰â­ æ¨è

**åŸç†**ï¼šç”¨æ•°å­¦æ›²çº¿ï¼ˆå“åº”æ›²çº¿ï¼‰è¯„ä¼°æ¯ä¸ªè¡Œä¸ºçš„"æ•ˆç”¨å€¼"ï¼Œé€‰æ‹©æœ€é«˜çš„

**ä¼˜åŠ¿**ï¼š
- ğŸ“‰ ä»£ç é‡ï¼š16 ä¸ª Intent ç±» â†’ 5-7 ä¸ªæ•ˆç”¨å‡½æ•° + é…ç½®æ–‡ä»¶
- ğŸ¯ å¯è°ƒè¯•ï¼šæ‰€æœ‰æƒé‡åœ¨é…ç½®æ–‡ä»¶ä¸­ï¼Œä¸€ç›®äº†ç„¶
- ğŸ”„ çµæ´»æ€§ï¼šè¿è¡Œæ—¶å¯è°ƒæ•´ï¼Œæ”¯æŒçƒ­é‡è½½
- ğŸ§  "èªæ˜"è¡¨ç°ï¼šå¤šå› ç´ æƒè¡¡è‡ªç„¶äº§ç”Ÿå¤æ‚å†³ç­–

#### å®ç°ç¤ºä¾‹

**1. å®šä¹‰æ•ˆç”¨è¯„ä¼°å™¨ï¼ˆUtilityEvaluatorï¼‰**

```java
// flyingsword/ai/utility/UtilityEvaluator.java
public record UtilityEvaluator(
    String name,
    UtilityFunction function,
    double weight
) {
    public double evaluate(UtilityContext ctx) {
        return function.calculate(ctx) * weight;
    }
}
```

**2. é¢„å®šä¹‰å“åº”æ›²çº¿ï¼ˆUtilityFunctionï¼‰**

```java
// flyingsword/ai/utility/UtilityFunction.java
public interface UtilityFunction {
    double calculate(UtilityContext ctx);

    // çº¿æ€§æ›²çº¿ï¼šè¶Šè¿‘è¶Šé«˜
    static UtilityFunction linearInverse(String key, double max) {
        return ctx -> Math.min(max / ctx.get(key), 1.0);
    }

    // Så‹æ›²çº¿ï¼šå¹³æ»‘è¿‡æ¸¡
    static UtilityFunction sigmoid(String key, double midpoint, double steepness) {
        return ctx -> 1.0 / (1.0 + Math.exp(-steepness * (ctx.get(key) - midpoint)));
    }

    // é˜ˆå€¼æ›²çº¿ï¼šè¾¾åˆ°æ¡ä»¶åæ¿€æ´»
    static UtilityFunction threshold(String key, double threshold, double outputHigh, double outputLow) {
        return ctx -> ctx.get(key) >= threshold ? outputHigh : outputLow;
    }

    // åæ¯”ä¾‹æ›²çº¿ï¼šè·ç¦»è¶Šè¿œæ•ˆç”¨è¶Šä½
    static UtilityFunction inverseDistance(String key, double scale) {
        return ctx -> scale / Math.max(ctx.get(key), 0.1);
    }
}
```

**3. é…ç½®æ–‡ä»¶é©±åŠ¨ï¼ˆJSONï¼‰**

```json5
// data/chestcavity/flyingsword/ai/utility_profiles.json
{
  "hunt_mode": {
    "actions": [
      {
        "name": "assassinate_weak",
        "trajectory": "PredictiveLine",
        "evaluators": [
          {"function": "inverse_health", "weight": 12.0},  // ä¼˜å…ˆä½è¡€é‡
          {"function": "inverse_distance", "weight": 3.0},  // è¶Šè¿‘è¶Šå¥½
          {"function": "has_mark", "weight": 5.0}           // å·²æ ‡è®°ç›®æ ‡åŠ åˆ†
        ]
      },
      {
        "name": "duel_strong",
        "trajectory": "Corkscrew",
        "evaluators": [
          {"function": "health_ratio", "weight": 8.0},      // ä¼˜å…ˆé«˜è¡€é‡
          {"function": "is_elite", "weight": 10.0},         // ç²¾è‹±å•ä½
          {"function": "threat_level", "weight": 6.0}       // å¨èƒç­‰çº§
        ]
      },
      {
        "name": "intercept_mobile",
        "trajectory": "CurvedIntercept",
        "evaluators": [
          {"function": "velocity_magnitude", "weight": 5.0}, // ç§»åŠ¨é€Ÿåº¦é«˜
          {"function": "inverse_distance", "weight": 2.0},
          {"function": "has_ranged_attack", "weight": 4.0}   // è¿œç¨‹å•ä½
        ]
      }
    ]
  }
}
```

**4. æ•ˆç”¨è§„åˆ’å™¨ï¼ˆUtilityPlannerï¼‰**

```java
// flyingsword/ai/utility/UtilityPlanner.java
public final class UtilityPlanner {

    private static final Map<AIMode, List<UtilityAction>> PROFILES = new HashMap<>();

    public static Optional<IntentResult> pickBest(UtilityContext ctx) {
        AIMode mode = ctx.getSword().getAIMode();
        List<UtilityAction> actions = PROFILES.get(mode);

        return actions.stream()
            .map(action -> {
                // è®¡ç®—æ€»æ•ˆç”¨å€¼
                double utility = action.getEvaluators().stream()
                    .mapToDouble(eval -> eval.evaluate(ctx))
                    .sum();

                return new ScoredAction(action, utility);
            })
            .max(Comparator.comparingDouble(ScoredAction::utility))
            .map(scored -> IntentResult.builder()
                .trajectory(scored.action().getTrajectoryType())
                .priority(scored.utility())
                .target(ctx.getBestTarget())
                .build());
    }

    record ScoredAction(UtilityAction action, double utility) {}
}
```

**æ•ˆæœå¯¹æ¯”**ï¼š

| ç»´åº¦ | å½“å‰ Intent ç³»ç»Ÿ | æ•ˆç”¨AIç³»ç»Ÿ |
|------|----------------|-----------|
| **ä»£ç é‡** | 16 ä¸ª Java ç±» (800+ è¡Œ) | 1 ä¸ªè§„åˆ’å™¨ + é…ç½®æ–‡ä»¶ (200 è¡Œä»£ç  + 100 è¡Œ JSON) |
| **å¯è°ƒè¯•æ€§** | ä¼˜å…ˆçº§å…¬å¼æ•£è½åœ¨ä»£ç ä¸­ | æ‰€æœ‰æƒé‡é›†ä¸­åœ¨é…ç½®æ–‡ä»¶ |
| **çµæ´»æ€§** | ä¿®æ”¹éœ€è¦é‡æ–°ç¼–è¯‘ | çƒ­é‡è½½é…ç½®æ–‡ä»¶ |
| **å†³ç­–é€æ˜åº¦** | æ— æ³•çœ‹åˆ°å†³ç­–è¿‡ç¨‹ | æ¯ä¸ªå› ç´ çš„è´¡çŒ®å¯è§†åŒ– |
| **"èªæ˜"ç¨‹åº¦** | å•ä¸€å› ç´ ä¸»å¯¼ | å¤šå› ç´ è‡ªç„¶æƒè¡¡ |

---

### æ–¹æ¡ˆ Bï¼šé»‘æ¿ç³»ç»Ÿï¼ˆBlackboard Systemï¼‰+ ç¼“å­˜

**é—®é¢˜**ï¼šå½“å‰ AIContext åªæœ‰ 4 ä¸ªå­—æ®µï¼Œæ¯ä¸ª Intent éƒ½è¦é‡å¤æœç´¢ç›®æ ‡

**è§£å†³**ï¼šå»ºç«‹"é»‘æ¿"ï¼ˆå…±äº«ä¿¡æ¯æ± ï¼‰ï¼Œä¸€æ¬¡æœç´¢å¤šæ¬¡ä½¿ç”¨

#### å®ç°ç¤ºä¾‹

```java
// flyingsword/ai/blackboard/SwordBlackboard.java
public class SwordBlackboard {
    private final FlyingSwordEntity sword;
    private final Map<String, Object> data = new HashMap<>();
    private long lastUpdateTick = -1;

    // æ‡’åŠ è½½ï¼šé¦–æ¬¡è®¿é—®æ—¶æ‰è®¡ç®—
    public List<LivingEntity> getNearbyHostiles() {
        return computeIfAbsent("nearby_hostiles", () ->
            TargetFinder.findAllHostilesInRange(sword, 32.0)
        );
    }

    public Optional<LivingEntity> getLowestHealthTarget() {
        return computeIfAbsent("lowest_health", () ->
            getNearbyHostiles().stream()
                .min(Comparator.comparingDouble(LivingEntity::getHealth))
        );
    }

    public Optional<LivingEntity> getHighestThreatTarget() {
        return computeIfAbsent("highest_threat", () ->
            TargetFinder.findHighThreatMelee(sword.level(), sword.getOwner(), 32.0)
        );
    }

    public Vec3 getClusterCenter() {
        return computeIfAbsent("cluster_center", () ->
            TargetFinder.estimateHostileClusterCenter(sword.level(), sword.position(), 32.0)
        );
    }

    // æ¯å¸§å¼€å§‹æ—¶æ¸…ç©ºç¼“å­˜
    public void tickReset(long currentTick) {
        if (lastUpdateTick != currentTick) {
            data.clear();
            lastUpdateTick = currentTick;
        }
    }

    @SuppressWarnings("unchecked")
    private <T> T computeIfAbsent(String key, Supplier<T> supplier) {
        return (T) data.computeIfAbsent(key, k -> supplier.get());
    }
}
```

**æ€§èƒ½æå‡**ï¼š
- å½“å‰ï¼šæ¯ä¸ª Intent å•ç‹¬æœç´¢ â†’ **8 æ¬¡ AABB æŸ¥è¯¢ / å¸§**
- é»‘æ¿ï¼šé¦–æ¬¡æœç´¢åç¼“å­˜ â†’ **1 æ¬¡ AABB æŸ¥è¯¢ / å¸§**
- æ€§èƒ½æå‡ï¼š**~8x**

---

### æ–¹æ¡ˆ Cï¼šè¡Œä¸ºæ ‘ç®€åŒ–ï¼ˆBehavior Tree Liteï¼‰

**åŸç†**ï¼šç”¨æ ‘çŠ¶ç»“æ„ç»„ç»‡å†³ç­–é€»è¾‘ï¼Œæ¯” Intent åˆ—è¡¨æ›´ç›´è§‚

#### å®ç°ç¤ºä¾‹

```java
// flyingsword/ai/btree/BehaviorNode.java
public interface BehaviorNode {
    enum Status { SUCCESS, FAILURE, RUNNING }
    Status tick(SwordBlackboard ctx);
}

// é€‰æ‹©èŠ‚ç‚¹ï¼šä»å·¦åˆ°å³å°è¯•ï¼Œç›´åˆ°æˆåŠŸ
class SelectorNode implements BehaviorNode {
    private final List<BehaviorNode> children;

    public Status tick(SwordBlackboard ctx) {
        for (var child : children) {
            Status status = child.tick(ctx);
            if (status != Status.FAILURE) return status;
        }
        return Status.FAILURE;
    }
}

// åºåˆ—èŠ‚ç‚¹ï¼šå¿…é¡»å…¨éƒ¨æˆåŠŸ
class SequenceNode implements BehaviorNode {
    private final List<BehaviorNode> children;

    public Status tick(SwordBlackboard ctx) {
        for (var child : children) {
            Status status = child.tick(ctx);
            if (status != Status.SUCCESS) return status;
        }
        return Status.SUCCESS;
    }
}

// æ¡ä»¶èŠ‚ç‚¹
class ConditionNode implements BehaviorNode {
    private final Predicate<SwordBlackboard> condition;

    public Status tick(SwordBlackboard ctx) {
        return condition.test(ctx) ? Status.SUCCESS : Status.FAILURE;
    }
}

// è¡ŒåŠ¨èŠ‚ç‚¹
class ActionNode implements BehaviorNode {
    private final Consumer<SwordBlackboard> action;

    public Status tick(SwordBlackboard ctx) {
        action.accept(ctx);
        return Status.SUCCESS;
    }
}
```

**HUNT æ¨¡å¼è¡Œä¸ºæ ‘ç¤ºä¾‹**ï¼š

```java
// flyingsword/ai/btree/HuntBehaviorTree.java
BehaviorNode huntTree = new SelectorNode(List.of(
    // 1. å¦‚æœæœ‰æ ‡è®°ç›®æ ‡ â†’ çŒæ€
    new SequenceNode(List.of(
        new ConditionNode(ctx -> ctx.getMarkedTarget().isPresent()),
        new ActionNode(ctx -> attackTarget(ctx, ctx.getMarkedTarget().get(), "PredictiveLine"))
    )),

    // 2. å¦‚æœæœ‰ä½è¡€é‡æ•Œäºº â†’ åˆºæ€
    new SequenceNode(List.of(
        new ConditionNode(ctx -> {
            var target = ctx.getLowestHealthTarget();
            return target.isPresent() && target.get().getHealth() < target.get().getMaxHealth() * 0.3;
        }),
        new ActionNode(ctx -> attackTarget(ctx, ctx.getLowestHealthTarget().get(), "PredictiveLine"))
    )),

    // 3. å¦‚æœæœ‰é«˜å¨èƒæ•Œäºº â†’ ç¼ æ–—
    new SequenceNode(List.of(
        new ConditionNode(ctx -> ctx.getHighestThreatTarget().isPresent()),
        new ActionNode(ctx -> attackTarget(ctx, ctx.getHighestThreatTarget().get(), "Corkscrew"))
    )),

    // 4. é»˜è®¤ï¼šå·¡é€»æœç´¢
    new ActionNode(ctx -> patrolSearch(ctx))
));
```

**ä¼˜åŠ¿**ï¼š
- ğŸ“Š å¯è§†åŒ–ï¼šå¯ä»¥ç”»æˆå†³ç­–æ ‘å›¾
- ğŸ® ç›´è§‚ï¼šä»ä¸Šåˆ°ä¸‹é˜…è¯»ï¼Œåƒæ¸¸æˆè„šæœ¬
- ğŸ”§ æ˜“è°ƒè¯•ï¼šæ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æ‰“å°çŠ¶æ€
- ğŸ“¦ å¤ç”¨æ€§ï¼šå­æ ‘å¯ä»¥åœ¨ä¸åŒæ¨¡å¼é—´å…±äº«

---

### æ–¹æ¡ˆ Dï¼šè¡¨ç°å±‚å¢å¼ºï¼ˆè§†è§‰æ™ºèƒ½ï¼‰ğŸ¨

**æ ¸å¿ƒæ€æƒ³**ï¼šé€šè¿‡åŠ¨ç”»å’Œç‰¹æ•ˆè®©AI"çœ‹èµ·æ¥"æ›´èªæ˜ï¼Œè€Œä¸æ”¹å˜å†³ç­–é€»è¾‘

#### 4.1 é¢„åˆ¤åŠ¨ç”»

```java
// é£å‰‘é”å®šç›®æ ‡æ—¶ï¼š
// 1. å…ˆ"æ‚¬åœ"0.2ç§’ï¼ˆç›¯ç€ç›®æ ‡ï¼‰
// 2. å‰‘å°–å‘å…‰ç²’å­èšé›†
// 3. ç„¶åçˆ†å‘å†²åˆº

public void onTargetAcquired(LivingEntity target) {
    // è§†è§‰æš‚åœ
    sword.setDeltaMovement(Vec3.ZERO);

    // å¯¹å‡†ç›®æ ‡
    Vec3 lookDir = target.position().subtract(sword.position()).normalize();
    sword.setYRot((float) Math.toDegrees(Math.atan2(lookDir.z, lookDir.x)));

    // ç²’å­æ•ˆæœï¼ˆèšæ°”ï¼‰
    spawnChargeParticles(sword, 4); // 0.2ç§’ = 4 ticks

    // å»¶è¿Ÿå†²åˆº
    sword.level().scheduleTick(sword, () -> {
        sword.setDeltaMovement(lookDir.scale(maxSpeed));
        spawnDashParticles(sword);
    }, 4);
}
```

**æ•ˆæœ**ï¼šç©å®¶ä¼šè§‰å¾—"é£å‰‘åœ¨ç„å‡†"ï¼Œå®é™…ä¸Šåªæ˜¯å»¶è¿Ÿäº† 0.2 ç§’

#### 4.2 åä½œå…‰æ•ˆ

```java
// å¤šæŠŠå‰‘æ”»å‡»åŒä¸€ç›®æ ‡æ—¶æ˜¾ç¤ºè¿çº¿
public void renderCooperationLinks(PoseStack poseStack, MultiBufferSource bufferSource) {
    List<FlyingSwordEntity> allySwords = getNearbyAllySwords(32.0);
    LivingEntity myTarget = this.getTarget();

    if (myTarget == null) return;

    for (var ally : allySwords) {
        if (ally.getTarget() == myTarget) {
            // ç»˜åˆ¶å‰‘â†’ç›®æ ‡çš„èƒ½é‡è¿çº¿
            renderEnergyBeam(poseStack, bufferSource,
                this.position(), myTarget.position(),
                0x40FF4040, 2.0f); // åŠé€æ˜çº¢è‰²
        }
    }
}
```

**æ•ˆæœ**ï¼šç©å®¶çœ‹åˆ°å…‰æŸä¼šè§‰å¾—"é£å‰‘åœ¨ååŒæ”»å‡»"

#### 4.3 æƒ…å¢ƒéŸ³æ•ˆ

```java
// æ ¹æ®çŠ¶æ€æ’­æ”¾ä¸åŒéŸ³æ•ˆ
public void playContextualSound() {
    AIMode mode = getAIMode();
    float speed = (float) getDeltaMovement().length();

    if (mode == AIMode.HUNT && speed > 0.8) {
        // é«˜é€Ÿè¿½å‡»ï¼šå°–é”ç ´ç©ºå£°
        playSound(CCGuSounds.SWORD_DASH, 1.0f, 1.5f);
    } else if (mode == AIMode.GUARD) {
        // é˜²å®ˆï¼šä½é¢‘å—¡é¸£
        playSound(CCGuSounds.SWORD_ORBIT, 0.6f, 0.8f);
    } else if (isNearOwner(3.0)) {
        // é è¿‘ä¸»äººï¼šæŸ”å’Œå‰‘é¸£
        playSound(CCGuSounds.SWORD_IDLE, 0.4f, 1.0f);
    }
}
```

#### 4.4 åŠ¨æ€è½¨è¿¹æ¸²æŸ“

```java
// æ¸²æŸ“é£å‰‘çš„"æ„å›¾è½¨è¿¹"ï¼ˆé¢„æµ‹è·¯å¾„ï¼‰
public void renderIntentPath(PoseStack poseStack, MultiBufferSource bufferSource) {
    if (this.currentIntent == null) return;

    // è®¡ç®—æœªæ¥ 1 ç§’çš„è½¨è¿¹ç‚¹
    List<Vec3> pathPoints = new ArrayList<>();
    Vec3 pos = position();
    Vec3 vel = getDeltaMovement();

    for (int i = 0; i < 20; i++) { // 20 ticks = 1 ç§’
        pos = pos.add(vel);
        pathPoints.add(pos);

        // ç®€å•ç‰©ç†æ¨¡æ‹Ÿï¼ˆå¯é€‰ï¼‰
        vel = trajectory.computeDesiredVelocity(pos, currentIntent);
    }

    // æ¸²æŸ“è™šçº¿è·¯å¾„
    for (int i = 0; i < pathPoints.size() - 1; i++) {
        if (i % 2 == 0) { // è™šçº¿æ•ˆæœ
            renderLine(poseStack, bufferSource,
                pathPoints.get(i), pathPoints.get(i + 1),
                0x8080FF80, 1.0f); // åŠé€æ˜ç»¿è‰²
        }
    }
}
```

**æ•ˆæœ**ï¼šç©å®¶çœ‹åˆ°é£å‰‘çš„"æ€è€ƒè½¨è¿¹"ï¼Œæ„Ÿè§‰å¾ˆ"æœ‰è°‹ç•¥"

---

### æ–¹æ¡ˆ Eï¼šè®°å¿†ä¸é€‚åº”ç³»ç»Ÿ

**é—®é¢˜**ï¼šé£å‰‘ä¼šåå¤æ”»å‡»æ— æ•Œç›®æ ‡ï¼ˆå¦‚å±éšœä¿æŠ¤çš„æ•Œäººï¼‰

**è§£å†³**ï¼šçŸ­æœŸè®°å¿† + å¤±è´¥æƒ©ç½š

```java
// flyingsword/ai/memory/SwordMemory.java
public class SwordMemory {
    // è®°å½•æœ€è¿‘ N æ¬¡æ”»å‡»å¤±è´¥çš„ç›®æ ‡
    private final Map<UUID, FailureRecord> recentFailures = new HashMap<>();

    record FailureRecord(int failureCount, long lastAttempt) {}

    public void recordFailure(LivingEntity target) {
        UUID id = target.getUUID();
        FailureRecord old = recentFailures.get(id);

        if (old == null) {
            recentFailures.put(id, new FailureRecord(1, level.getGameTime()));
        } else {
            recentFailures.put(id, new FailureRecord(old.failureCount + 1, level.getGameTime()));
        }
    }

    public double getFailurePenalty(LivingEntity target) {
        FailureRecord record = recentFailures.get(target.getUUID());
        if (record == null) return 1.0;

        // å¤±è´¥è¶Šå¤šï¼Œä¼˜å…ˆçº§æƒ©ç½šè¶Šå¤§
        return Math.max(0.1, 1.0 - (record.failureCount * 0.2));
    }

    public void tick() {
        long now = level.getGameTime();
        // æ¸…ç† 10 ç§’å‰çš„è®°å½•
        recentFailures.entrySet().removeIf(entry ->
            now - entry.getValue().lastAttempt > 200
        );
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
// åœ¨æ•ˆç”¨è¯„ä¼°ä¸­åº”ç”¨è®°å¿†æƒ©ç½š
double utility = baseUtility * sword.getMemory().getFailurePenalty(target);
```

**æ•ˆæœ**ï¼š
- æ”»å‡»æ— æ•Œç›®æ ‡ 3 æ¬¡å â†’ ä¼˜å…ˆçº§é™è‡³ 40%
- 10 ç§’åè®°å¿†æ¶ˆé€€ â†’ å¯ä»¥é‡æ–°å°è¯•

---

## å®æ–½è·¯çº¿å›¾ ğŸ—ºï¸

### é˜¶æ®µ 1ï¼šé»‘æ¿ç³»ç»Ÿï¼ˆ1-2 å¤©ï¼‰âš¡ å¿«é€Ÿè§æ•ˆ

**ç›®æ ‡**ï¼šå‡å°‘ 80% çš„é‡å¤è®¡ç®—

1. åˆ›å»º `SwordBlackboard` ç±»
2. æ‰©å±• `AIContext` åŒ…å«é»‘æ¿å¼•ç”¨
3. é‡æ„ `TargetFinder` ä¸ºé»‘æ¿æ–¹æ³•
4. æ›´æ–° Intent è¯„ä¼°ä½¿ç”¨é»‘æ¿

**é¢„æœŸæ”¶ç›Š**ï¼š
- æ€§èƒ½æå‡ 5-8x
- ä»£ç è¡Œæ•°å‡å°‘ 200+

### é˜¶æ®µ 2ï¼šæ•ˆç”¨AIç³»ç»Ÿï¼ˆ3-4 å¤©ï¼‰ğŸ¯ æ¨è

**ç›®æ ‡**ï¼šå°† 16 ä¸ª Intent ç±»ç²¾ç®€ä¸ºé…ç½®é©±åŠ¨

1. å®ç° `UtilityFunction` å·¥å…·ç±»
2. åˆ›å»º `UtilityPlanner` æ›¿ä»£ `IntentPlanner`
3. ç¼–å†™ JSON é…ç½®æ–‡ä»¶
4. æ·»åŠ è°ƒè¯•æ—¥å¿—ï¼ˆæ˜¾ç¤ºæ¯ä¸ªå› ç´ çš„è´¡çŒ®ï¼‰

**é¢„æœŸæ”¶ç›Š**ï¼š
- ä»£ç è¡Œæ•°å‡å°‘ 600+
- å¯è°ƒè¯•æ€§æå‡ 10x
- æ”¯æŒçƒ­é‡è½½é…ç½®

### é˜¶æ®µ 3ï¼šè¡¨ç°å±‚å¢å¼ºï¼ˆ2-3 å¤©ï¼‰ğŸ¨ å³æ—¶åé¦ˆ

**ç›®æ ‡**ï¼šè®©é£å‰‘"çœ‹èµ·æ¥"æ›´èªæ˜

1. æ·»åŠ ç›®æ ‡é”å®šåŠ¨ç”»
2. åä½œå…‰æ•ˆæ¸²æŸ“
3. æƒ…å¢ƒéŸ³æ•ˆç³»ç»Ÿ
4. æ„å›¾è½¨è¿¹å¯è§†åŒ–ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰

**é¢„æœŸæ”¶ç›Š**ï¼š
- ç©å®¶æ„ŸçŸ¥æ™ºèƒ½æå‡ 3x
- æ— éœ€æ”¹åŠ¨æ ¸å¿ƒé€»è¾‘

### é˜¶æ®µ 4ï¼ˆå¯é€‰ï¼‰ï¼šè¡Œä¸ºæ ‘è¿ç§»ï¼ˆ4-5 å¤©ï¼‰

**ç›®æ ‡**ï¼šç”¨è¡Œä¸ºæ ‘æ›¿ä»£ Intent ç³»ç»Ÿ

1. å®ç°åŸºç¡€è¡Œä¸ºæ ‘èŠ‚ç‚¹
2. ä¸ºæ¯ä¸ª AIMode ç¼–å†™è¡Œä¸ºæ ‘
3. è¿ç§»ç°æœ‰è¡Œä¸ºåˆ°æ ‘èŠ‚ç‚¹
4. æ·»åŠ å¯è§†åŒ–è°ƒè¯•å·¥å…·

**é¢„æœŸæ”¶ç›Š**ï¼š
- å†³ç­–æµç¨‹å¯è§†åŒ–
- æ›´å¥½çš„å¤ç”¨æ€§

---

## ä»£ç é‡å¯¹æ¯” ğŸ“Š

| ç»„ä»¶ | å½“å‰å®ç° | æ•ˆç”¨AIæ–¹æ¡ˆ | è¡Œä¸ºæ ‘æ–¹æ¡ˆ | èŠ‚çœ |
|------|---------|-----------|-----------|------|
| Intent ç±» | 16 Ã— 50 è¡Œ = 800 è¡Œ | 0 è¡Œ | 0 è¡Œ | **-800** |
| TargetFinder | 575 è¡Œ | 150 è¡Œï¼ˆé»‘æ¿æ–¹æ³•ï¼‰ | 150 è¡Œ | **-425** |
| Planner | 74 è¡Œ | 120 è¡Œï¼ˆUtilityPlannerï¼‰ | 200 è¡Œï¼ˆBehaviorTreeï¼‰ | -/+ |
| é…ç½® | 0 è¡Œ | 100 è¡Œ JSON | 150 è¡Œ JSON | +100 |
| å·¥å…·ç±» | 0 è¡Œ | 80 è¡Œï¼ˆUtilityFunctionï¼‰ | 100 è¡Œï¼ˆTreeNodesï¼‰ | +80 |
| **æ€»è®¡** | **1449 è¡Œ** | **450 è¡Œ** | **600 è¡Œ** | **-1000** æˆ– **-850** |

**å…³é”®æŒ‡æ ‡**ï¼š
- ä»£ç å¤æ‚åº¦é™ä½ï¼š**~70%**
- å¯ç»´æŠ¤æ€§æå‡ï¼šé…ç½®æ–‡ä»¶ vs ç¡¬ç¼–ç 
- æ€§èƒ½æå‡ï¼š**5-8x**ï¼ˆé»‘æ¿ç¼“å­˜ï¼‰

---

## è°ƒè¯•ä¸å¯è§†åŒ–å·¥å…· ğŸ”§

### å†³ç­–æ—¥å¿—è¾“å‡º

```java
// flyingsword/ai/debug/DecisionLogger.java
public class DecisionLogger {
    private static final Logger LOGGER = LogUtils.getLogger();
    private static final boolean DEBUG = Boolean.getBoolean("cc.flyingsword.debug");

    public static void logUtilityDecision(FlyingSwordEntity sword, List<ScoredAction> scores) {
        if (!DEBUG) return;

        LOGGER.info("=== Sword {} Decision ===", sword.getId());
        scores.forEach(scored -> {
            LOGGER.info("  {} â†’ utility: {:.2f}",
                scored.action().getName(),
                scored.utility());

            // è¯¦ç»†åˆ†è§£
            scored.action().getEvaluators().forEach(eval -> {
                double contribution = eval.evaluate(sword.getBlackboard());
                LOGGER.info("    - {}: {:.2f} (weight: {:.2f})",
                    eval.name(), contribution, eval.weight());
            });
        });
        LOGGER.info("  CHOSEN: {}", scores.get(0).action().getName());
    }
}
```

**ç¤ºä¾‹è¾“å‡º**ï¼š

```
=== Sword 12345 Decision ===
  assassinate_weak â†’ utility: 18.5
    - inverse_health: 9.6 (weight: 12.0)
    - inverse_distance: 6.0 (weight: 3.0)
    - has_mark: 0.0 (weight: 5.0)
  duel_strong â†’ utility: 14.2
    - health_ratio: 6.4 (weight: 8.0)
    - is_elite: 0.0 (weight: 10.0)
    - threat_level: 4.8 (weight: 6.0)
  intercept_mobile â†’ utility: 8.3
    - velocity_magnitude: 2.5 (weight: 5.0)
    - inverse_distance: 6.0 (weight: 2.0)
    - has_ranged_attack: 0.0 (weight: 4.0)
  CHOSEN: assassinate_weak
```

### æ¸¸æˆå†…å¯è§†åŒ–

```java
// å¯ç”¨è°ƒè¯•æ¨¡å¼åï¼Œæ¸²æŸ“å†³ç­–ä¿¡æ¯
if (DEBUG_MODE) {
    // åœ¨é£å‰‘å¤´é¡¶æ˜¾ç¤ºå½“å‰æ„å›¾
    renderFloatingText(sword.position().add(0, 1, 0),
        "Intent: " + currentAction.getName(),
        0xFFFFFF);

    // æ¸²æŸ“ç›®æ ‡è¿çº¿
    if (currentTarget != null) {
        renderLine(sword.position(), currentTarget.position(), 0xFF0000);
    }

    // æ¸²æŸ“é»‘æ¿ä¿¡æ¯
    renderBlackboardInfo(sword.getBlackboard());
}
```

---

## ä¸é‡æ„è®¡åˆ’çš„æ•´åˆ ğŸ”—

**åœ¨ Phase 1 ä¸­æ•´åˆ**ï¼š
- æ·»åŠ  `ENABLE_UTILITY_AI` å¼€å…³ï¼ˆé»˜è®¤å…³é—­ï¼‰
- ä¿ç•™ç°æœ‰ Intent ç³»ç»Ÿä½œä¸ºå›é€€

**åœ¨ Phase 2 ä¸­æ•´åˆ**ï¼š
- å°† UtilityPlanner æ”¾å…¥ `systems/decision/`
- é»‘æ¿ç³»ç»Ÿæ”¾å…¥ `systems/perception/`
- è®°å¿†ç³»ç»Ÿæ”¾å…¥ `systems/memory/`

**åœ¨ Phase 6 ä¸­æ•´åˆ**ï¼š
- è¡¥å……æ•ˆç”¨AIä½¿ç”¨æ–‡æ¡£
- æ·»åŠ å“åº”æ›²çº¿è°ƒä¼˜æŒ‡å—
- ç¼–å†™ JSON é…ç½®ç¤ºä¾‹

---

## æ€»ç»“ï¼šä¸ºä»€ä¹ˆè¿™äº›æ–¹æ¡ˆ"èªæ˜ä½†ç®€å•"ï¼Ÿ

### ğŸ¯ æ•ˆç”¨AIç³»ç»Ÿ
- **ç®€å•**ï¼šæ•°å­¦æ›²çº¿ + é…ç½®æ–‡ä»¶
- **èªæ˜**ï¼šå¤šå› ç´ è‡ªç„¶æƒè¡¡äº§ç”Ÿå¤æ‚å†³ç­–

### ğŸ§  é»‘æ¿ç³»ç»Ÿ
- **ç®€å•**ï¼šæ‡’åŠ è½½ç¼“å­˜
- **èªæ˜**ï¼šæ¶ˆé™¤é‡å¤è®¡ç®—ï¼Œæå‡å“åº”é€Ÿåº¦

### ğŸ¨ è¡¨ç°å±‚å¢å¼º
- **ç®€å•**ï¼šåŠ¨ç”» + ç²’å­ + éŸ³æ•ˆ
- **èªæ˜**ï¼šç©å®¶æ„ŸçŸ¥æ™ºèƒ½æå‡ 3x

### ğŸŒ³ è¡Œä¸ºæ ‘ï¼ˆå¯é€‰ï¼‰
- **ç®€å•**ï¼šä»ä¸Šåˆ°ä¸‹è¯»å†³ç­–æ ‘
- **èªæ˜**ï¼šç›´è§‚çš„ä¼˜å…ˆçº§å’Œå›é€€é€»è¾‘

### ğŸ’¾ è®°å¿†ç³»ç»Ÿ
- **ç®€å•**ï¼šå¤±è´¥è®¡æ•° + æ—¶é—´è¡°å‡
- **èªæ˜**ï¼šé¿å…é‡å¤é”™è¯¯

---

## æ¨èå®æ–½é¡ºåº

1. **ğŸš€ é˜¶æ®µ 1ï¼šé»‘æ¿ç³»ç»Ÿ**ï¼ˆå¿«é€Ÿè§æ•ˆï¼Œ2å¤©ï¼‰
2. **ğŸ¨ é˜¶æ®µ 3ï¼šè¡¨ç°å±‚å¢å¼º**ï¼ˆç«‹å³å¯è§ï¼Œ3å¤©ï¼‰
3. **ğŸ¯ é˜¶æ®µ 2ï¼šæ•ˆç”¨AIç³»ç»Ÿ**ï¼ˆæ ¸å¿ƒé‡æ„ï¼Œ4å¤©ï¼‰
4. **ğŸ“ æ–‡æ¡£ä¸è°ƒè¯•å·¥å…·**ï¼ˆè´¯ç©¿æ•´ä¸ªè¿‡ç¨‹ï¼‰

**æ€»å·¥ä½œé‡**ï¼š9-12 å¤©

**æ ¸å¿ƒç†å¿µå†å¼ºè°ƒ**ï¼š
> çœŸæ­£çš„æ™ºèƒ½ä¸æ˜¯å †ç Œ if-elseï¼Œè€Œæ˜¯é€‰æ‹©æ­£ç¡®çš„æŠ½è±¡å±‚ã€‚ç”¨æ•°å­¦æ›²çº¿ã€ç¼“å­˜ã€åŠ¨ç”»ç‰¹æ•ˆè¿™äº›ç®€å•å·¥å…·ï¼Œå¯ä»¥åˆ›é€ å‡ºè¿œè¶…å¤æ‚ä»£ç çš„"èªæ˜"è¡¨ç°ã€‚

---

## å‚è€ƒèµ„æº

1. **Utility AI Theory**: [GDC 2010 - Behavioral Mathematics for Game AI](https://www.gdcvault.com/play/1012410/Behavior-Math-for)
2. **Behavior Trees**: [Unreal Engine - Behavior Trees](https://docs.unrealengine.com/5.0/en-US/behavior-trees-in-unreal-engine/)
3. **Blackboard Systems**: [AI Game Programming Wisdom](http://www.aiwisdom.com/)
4. **Response Curves**: [Building Better AI through Utility Theory](https://www.gamedeveloper.com/programming/creating-a-utility-based-ai-using-response-curves)
