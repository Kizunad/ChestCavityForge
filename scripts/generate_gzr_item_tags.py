#!/usr/bin/env python3
"""
从 Guzhenren data 标签目录生成 TagKey 常量定义。

示例用法：
    python scripts/generate_gzr_item_tags.py \
        /home/kiz/Code/java/decompile/10_6_decompile/data/guzhenren/tags/item \
        --emit-class \
        --package net.tigereye.chestcavity.compat.guzhenren.registry \
        --class-name GZRItemTags

默认仅输出常量定义行，可配合 --emit-class 生成完整 Java 类。
"""

from __future__ import annotations

import argparse
import pathlib
import re
import sys
from dataclasses import dataclass
from typing import Iterable, List, Sequence


@dataclass(frozen=True)
class TagEntry:
    constant: str
    resource_path: str


def parse_arguments(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="扫描 data/<namespace>/tags/item 目录，生成 TagKey<Item> 常量定义")
    parser.add_argument(
        "data_dir",
        type=pathlib.Path,
        help="包含 *.json 标签文件的目录（例如 data/guzhenren/tags/item）")
    parser.add_argument(
        "--namespace",
        default="guzhenren",
        help="生成 ResourceLocation 时使用的命名空间（默认：guzhenren）")
    parser.add_argument(
        "--filter-suffix",
        default="_dao",
        help="仅处理文件名以该后缀结尾的标签，留空处理全部（默认：_dao）")
    parser.add_argument(
        "--package",
        default=None,
        help="生成完整 Java 类时使用的包名（需配合 --emit-class）")
    parser.add_argument(
        "--class-name",
        default="GZRItemTags",
        help="生成完整 Java 类时使用的类名（默认：GZRItemTags）")
    parser.add_argument(
        "--emit-class",
        action="store_true",
        help="输出完整 Java 类而非单独的常量定义行")
    parser.add_argument(
        "--output",
        type=pathlib.Path,
        default=None,
        help="将结果写入文件（默认输出到 stdout）")
    return parser.parse_args(argv)


def gather_entries(
    data_dir: pathlib.Path, filter_suffix: str | None
) -> List[TagEntry]:
    files = sorted(data_dir.rglob("*.json"))
    entries: List[TagEntry] = []
    for path in files:
        if filter_suffix:
            if not path.stem.endswith(filter_suffix):
                continue
        relative = path.relative_to(data_dir)
        resource_path = "/".join(part for part in relative.with_suffix("").parts)
        constant = to_constant_name(relative.with_suffix(""))
        entries.append(TagEntry(constant=constant, resource_path=resource_path))
    return entries


def to_constant_name(path: pathlib.Path) -> str:
    parts = []
    for part in path.parts:
        upper = re.sub(r"[^0-9A-Za-z]+", "_", part).upper()
        upper = re.sub(r"_+", "_", upper).strip("_")
        if not upper:
            continue
        if upper[0].isdigit():
            upper = f"_{upper}"
        parts.append(upper)
    return "_".join(parts)


def emit_constants(entries: Iterable[TagEntry]) -> List[str]:
    lines = []
    for entry in entries:
        lines.append(
            f'  public static final TagKey<Item> {entry.constant} = create("{entry.resource_path}");'
        )
    return lines


def emit_flow_map(entries: Iterable[TagEntry]) -> List[str]:
    lines = [
        "  public static final Map<String, TagKey<Item>> FLOW_TAGS = buildFlowTags();",
        "",
        "  private static Map<String, TagKey<Item>> buildFlowTags() {",
        "    Map<String, TagKey<Item>> map = new LinkedHashMap<>();",
    ]
    for entry in entries:
        lines.append(f'    map.put("{entry.resource_path}", {entry.constant});')
    lines.extend(
        [
            "    return Collections.unmodifiableMap(map);",
            "  }",
        ]
    )
    return lines


def emit_java_class(
    entries: Iterable[TagEntry],
    namespace: str,
    package: str | None,
    class_name: str,
) -> List[str]:
    lines: List[str] = []
    if package:
        lines.append(f"package {package};")
        lines.append("")
    lines.extend(
        [
            "import java.util.Collections;",
            "import java.util.LinkedHashMap;",
            "import java.util.Map;",
            "import net.minecraft.core.registries.Registries;",
            "import net.minecraft.resources.ResourceLocation;",
            "import net.minecraft.tags.TagKey;",
            "import net.minecraft.world.item.Item;",
            "",
            f"/** Auto-generated from data directory: generated by {pathlib.Path(__file__).name}. */",
            f"public final class {class_name} {{",
            f"  private static final String MOD_ID = \"{namespace}\";",
            "",
        ]
    )
    lines.extend(emit_constants(entries))
    lines.append("")
    lines.extend(emit_flow_map(entries))
    lines.extend(
        [
            "",
            f"  private {class_name}() {{}}",
            "",
            "  private static TagKey<Item> create(String path) {",
            "    return TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath(MOD_ID, path));",
            "  }",
            "}",
        ]
    )
    return lines


def main(argv: Sequence[str]) -> int:
    args = parse_arguments(argv)
    data_dir: pathlib.Path = args.data_dir
    if not data_dir.exists() or not data_dir.is_dir():
        print(f"[error] data_dir 不存在或不是目录: {data_dir}", file=sys.stderr)
        return 1

    filter_suffix = args.filter_suffix or None
    entries = gather_entries(data_dir, filter_suffix)
    if not entries:
        print("[warn] 未找到符合条件的标签文件", file=sys.stderr)

    if args.emit_class:
        if not args.package:
            print("[error] --emit-class 需要同时指定 --package", file=sys.stderr)
            return 1
        lines = emit_java_class(entries, args.namespace, args.package, args.class_name)
    else:
        lines = []
        lines.extend(emit_constants(entries))
        lines.append("")
        lines.extend(emit_flow_map(entries))

    output_text = "\n".join(lines)
    if args.output:
        args.output.write_text(output_text, encoding="utf-8")
    else:
        print(output_text)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
