plugins {
    id 'java'
    id 'java-library'
    id 'idea'
    id 'net.neoforged.moddev' version '2.0.14-beta'
    // 使用 GradleUp Shadow 做可选依赖重定位与打包（支持 Java 21 / Gradle 8+）
    id 'com.gradleup.shadow' version '9.2.2'
    id 'com.diffplug.spotless' version '6.25.0'
    id 'checkstyle'
    id 'jacoco'
}


version = mod_version
group = mod_group_id

// 默认内嵌的 Baritone 本地 Jar（如存在则自动启用，无需 -Pbaritone_local）
def __baritoneLocalDefault = file('libs/baritone-api-neoforge-1.11.2.jar')
// 可选的源码子模块 external/Baritone
def __baritoneProject = findProject(':external:Baritone')
// 统一开关：任一来源（源码子模块 / -Pbaritone_dep / -Pbaritone_local / 默认 libs jar）存在即启用打包
def __baritoneOff = project.hasProperty('baritone_off')
def __useBaritone = !__baritoneOff && 
        ((__baritoneProject != null) || project.hasProperty('baritone_dep') || project.hasProperty('baritone_local') || __baritoneLocalDefault.exists())

repositories {
    // 1. 本地 Maven 仓库
    mavenLocal()

    // 2. 项目内置离线仓库（通过 Git 同步），支持完全离线解析依赖
    maven {
        url = uri('./offline-repo')
    }

    // 3. 以下为在线仓库：在有网环境可用；离线环境建议使用 --offline，Gradle 不会访问这些地址
    mavenCentral()

    // NeoForge 官方
    maven { url = "https://maven.neoforged.net/releases" }

    // Cloth Config
    maven { url = "https://maven.shedaniel.me" }

    // GeckoLib
    maven { url = "https://dl.cloudsmith.io/public/geckolib3/geckolib/maven" }

    // Modern UI
    maven { url = "https://maven.izzel.io/releases" }

    // Optional: Baritone (enable via -Pbaritone_dep=group:artifact:version)
    if (project.hasProperty('baritone_dep')) {
        maven { url = "https://impactdevelopment.github.io/maven" }
        // Some forks publish to JitPack; add only if requested to avoid slowdown
        if (project.hasProperty('baritone_repo_jitpack')) {
            maven { url = "https://jitpack.io" }
        }
    }
}

base {
    archivesName = mod_id
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
    withSourcesJar()
}

spotless {
    java {
        googleJavaFormat('1.17.0')
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}

checkstyle {
    toolVersion = '10.20.0'
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        "charset": "UTF-8"
    ]
}

// 测试源集使用更宽松的缩进规则（2 空格），避免大规模格式化测试代码
tasks.named('checkstyleTest', Checkstyle).configure { t ->
    t.configFile = file("${rootDir}/config/checkstyle/checkstyle-test.xml")
}

neoForge {
    version = project.neo_version

    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    runs {
        client {
            client()
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        gameTestServer {
            type = 'gameTestServer'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            data()
            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').absolutePath, '--existing', file('src/main/resources/').absolutePath
        }

        configureEach {
            systemProperty 'forge.logging.markers', 'REGISTRIES'
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
        // 单 Jar 多 Mod：注册第二个模组供开发运行环境识别
        "guzhenren_event_ext" {
            sourceSet(sourceSets.main)
        }
    }
}

def mixinRefmapName = "${mod_id}.refmap.json"
def generatedMixinResourcesDir = layout.buildDirectory.dir("generated/mixins")
def generatedRefmapFile = generatedMixinResourcesDir.map { it.file(mixinRefmapName) }
def mixinDefaultObfuscation = findProperty('mixin_default_obfuscation') ?: 'notch'

sourceSets.main.resources {
    srcDir 'src/generated/resources'
    srcDir(generatedMixinResourcesDir)
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.register('scanStrengthOrgans', Exec) { task ->
    File scriptFile = project.file('scripts/scan_strength_organs.py')
    task.onlyIf { scriptFile.exists() }
    task.commandLine 'python3', scriptFile.absolutePath
}

tasks.register('generateCultivatorGuBugPools', Exec) { task ->
    File scriptFile = project.file('scripts/generate_cultivator_gu_bug_pools.py')
    task.onlyIf { scriptFile.exists() }
    task.commandLine 'python3', scriptFile.absolutePath
}

tasks.named('compileJava', JavaCompile).configure {
    dependsOn tasks.named('scanStrengthOrgans')
    dependsOn tasks.named('generateCultivatorGuBugPools')
    def refmapFile = generatedRefmapFile.get().asFile
    options.compilerArgs += [
            "-AdefaultObfuscationEnv=${mixinDefaultObfuscation}",
            "-AoutRefMapFile=${refmapFile.absolutePath}"
    ]
    doFirst {
        refmapFile.parentFile.mkdirs()
    }
}

tasks.named('compileTestJava', JavaCompile).configure {
    classpath = classpath.plus(tasks.named('compileJava', JavaCompile).get().classpath)
    options.annotationProcessorPath = tasks.named('compileJava', JavaCompile).get().options.annotationProcessorPath
}

// 在 'check' 阶段运行 Checkstyle（仅告警，不阻断构建）
tasks.named('check').configure {
    dependsOn tasks.named('checkstyleMain')
}

// 简易别名：`./gradlew lint` 仅运行 Checkstyle（输出 WARN，不阻断构建）
tasks.register('lint') { t ->
    t.group = 'verification'
    t.description = 'Run Checkstyle to lint code (warnings only).'
    t.dependsOn tasks.named('checkstyleMain')
}

// 校验 Guzhenren Event Extension 的事件 JSON 定义
// 提取注册类型 -> JSON（便于校验任务消费）
tasks.register('syncEventValidationTypes', Exec) { task ->
    File scriptFile = project.file('scripts/sync_event_validation_types.py')
    task.onlyIf { scriptFile.exists() }
    task.commandLine 'python3', scriptFile.absolutePath
    // 简化：显式声明与配置缓存不兼容（脚本执行读取文件系统）
    task.notCompatibleWithConfigurationCache('Runs external script to generate types; uses file system state')
}

tasks.register('validateGuzhenrenEvents') { t ->
    t.group = 'verification'
    t.description = 'Validate event JSON files under data/guzhenren_event_ext/events'
    // 优先确保类型清单已更新
    t.dependsOn tasks.named('syncEventValidationTypes')
    // 显式声明与配置缓存不兼容（动态文件扫描与日志输出）
    t.notCompatibleWithConfigurationCache('Scans file tree and uses dynamic project APIs during execution')

    doLast {
        def baseDir = file("src/main/resources/data/guzhenren_event_ext/events")
        if (!baseDir.exists()) {
            logger.lifecycle("[validateGuzhenrenEvents] 跳过：目录不存在 -> ${baseDir}")
            return
        }

        // 从 scripts/event_types.json 读取（若存在），否则使用回退集合
        def typesJson = file('scripts/event_types.json')
        def allowedTriggers
        def allowedConditions
        def allowedActions
        if (typesJson.exists()) {
            def parsed = new groovy.json.JsonSlurper().parse(typesJson)
            allowedTriggers = (parsed.triggers ?: []).toSet()
            allowedConditions = (parsed.conditions ?: []).toSet()
            allowedActions = (parsed.actions ?: []).toSet()
            logger.lifecycle("[validateGuzhenrenEvents] 使用 scripts/event_types.json 中的类型集合：T=${allowedTriggers.size()} C=${allowedConditions.size()} A=${allowedActions.size()}")
        } else {
            allowedTriggers = [
                'guzhenren_event_ext:player_obtained_item',
                'guzhenren_event_ext:player_stat_change',
                'guzhenren_event_ext:special_entity_killed',
            ] as Set

            allowedConditions = [
                'minecraft:random_chance',
                'guzhenren:player_health_percent',
                'guzhenren:player_daode',
                'guzhenren:player_daohen',
                'guzhenren_event_ext:check_variable',
                'guzhenren_event_ext:check_entity_tag',
            ] as Set

            allowedActions = [
                'guzhenren_event_ext:send_message',
                'guzhenren_event_ext:run_command',
                'guzhenren_event_ext:adjust_player_stat',
                'guzhenren_event_ext:spawn_hostile_gucultivator',
                'guzhenren_event_ext:set_variable',
                'guzhenren_event_ext:remove_variable',
                'guzhenren_event_ext:give_item',
            ] as Set
            logger.lifecycle("[validateGuzhenrenEvents] 回退至内置类型集合（未发现 scripts/event_types.json）")
        }

        def jsonFiles = fileTree(baseDir) {
            include '**/*.json'
        }.files.sort()

        if (jsonFiles.isEmpty()) {
            logger.lifecycle("[validateGuzhenrenEvents] 未找到事件 JSON 文件：${baseDir}")
            return
        }

        def slurper = new groovy.json.JsonSlurper()
        def errors = []
        def warnings = []
        def seenIds = [:].withDefault { [] }

        def rootPath = project.projectDir.toPath()

        jsonFiles.each { f ->
            def rel = rootPath.relativize(f.toPath()).toString()
            def data
            try {
                data = slurper.parse(f)
            } catch (Exception ex) {
                errors << "${rel}: 无法解析为 JSON -> ${ex.class.simpleName}: ${ex.message}"
                return
            }

            def list = []
            if (data instanceof List) {
                list = data
            } else if (data instanceof Map) {
                list = [data]
            } else {
                errors << "${rel}: 根类型必须为对象或数组"
                return
            }

            list.eachWithIndex { obj, idx ->
                def label = list.size() == 1 ? rel : "${rel}[@${idx}]"

                // id
                def id = obj.id
                if (!(id instanceof String) || id.trim().isEmpty()) {
                    errors << "${label}: 缺少必填字段 'id' 或类型非字符串"
                } else {
                    seenIds[id] << label
                    if (!id.startsWith('guzhenren_event_ext:')) {
                        warnings << "${label}: 建议 'id' 以 'guzhenren_event_ext:' 命名空间开头（当前: ${id})"
                    }
                }

                // trigger
                def trigger = obj.trigger
                if (!(trigger instanceof Map)) {
                    errors << "${label}: 缺少必填字段 'trigger' 或类型非对象"
                } else {
                    def triggerType = trigger.type ?: trigger.id // 兼容 id -> type
                    if (!(triggerType instanceof String) || triggerType.trim().isEmpty()) {
                        errors << "${label}: 触发器缺少 'type'（或 'id'）"
                    } else if (!allowedTriggers.contains(triggerType)) {
                        errors << "${label}: 未注册的触发器类型 '${triggerType}'"
                    } else {
                        // 触发器特定校验
                        if (triggerType == 'guzhenren_event_ext:player_stat_change') {
                            if (!(trigger.stat instanceof String) || trigger.stat.trim().isEmpty()) {
                                errors << "${label}: player_stat_change 触发器必须提供 'stat'（否则不会被轮询监控）"
                            }
                            def hasFrom = trigger.containsKey('from')
                            def hasTo = trigger.containsKey('to')
                            if (!hasFrom && !hasTo) {
                                warnings << "${label}: player_stat_change 建议提供 'from' 或 'to' 以限定范围"
                            }
                        }
                    }
                }

                // conditions
                if (obj.containsKey('conditions')) {
                    def conditions = obj.conditions
                    if (!(conditions instanceof List)) {
                        errors << "${label}: 'conditions' 必须为数组"
                    } else {
                        conditions.eachWithIndex { c, ci ->
                            def cLabel = "${label}.conditions[@${ci}]"
                            if (!(c instanceof Map)) {
                                errors << "${cLabel}: 条件必须为对象"
                                return
                            }
                            def cType = c.type ?: c.id
                            if (!(cType instanceof String) || cType.trim().isEmpty()) {
                                errors << "${cLabel}: 缺少 'type'（或 'id'）"
                            } else if (!allowedConditions.contains(cType)) {
                                errors << "${cLabel}: 未注册的条件类型 '${cType}'"
                            } else if (cType == 'minecraft:random_chance') {
                                if (!c.containsKey('chance')) {
                                    errors << "${cLabel}: 缺少必填字段 'chance'"
                                } else {
                                    def ch = c.chance
                                    if (!(ch instanceof Number) || ch.doubleValue() < 0d || ch.doubleValue() > 1d) {
                                        errors << "${cLabel}: 'chance' 必须为 [0,1] 范围的数值"
                                    }
                                }
                            }
                        }
                    }
                }

                // actions
                if (obj.containsKey('actions')) {
                    def actions = obj.actions
                    if (!(actions instanceof List)) {
                        errors << "${label}: 'actions' 必须为数组"
                    } else if (actions.isEmpty()) {
                        warnings << "${label}: 未配置任何动作（事件将无副作用）"
                    } else {
                        actions.eachWithIndex { a, ai ->
                            def aLabel = "${label}.actions[@${ai}]"
                            if (!(a instanceof Map)) {
                                errors << "${aLabel}: 动作必须为对象"
                                return
                            }
                            def aType = a.type ?: a.id
                            if (!(aType instanceof String) || aType.trim().isEmpty()) {
                                errors << "${aLabel}: 缺少 'type'（或 'id'）"
                            } else if (!allowedActions.contains(aType)) {
                                errors << "${aLabel}: 未注册的动作类型 '${aType}'"
                            }
                        }
                    }
                }

                // trigger_once / enabled 类型提示
                if (obj.containsKey('trigger_once') && !(obj.trigger_once instanceof Boolean)) {
                    errors << "${label}: 'trigger_once' 必须为布尔值"
                }
                if (obj.containsKey('enabled') && !(obj.enabled instanceof Boolean)) {
                    errors << "${label}: 'enabled' 必须为布尔值"
                }
            }
        }

        // 重复 id 检查
        seenIds.each { k, v ->
            if (v.size() > 1) {
                errors << "重复的事件 id '${k}'，出现在：${v.join(', ')}"
            }
        }

        // 输出结果
        if (!warnings.isEmpty()) {
            logger.lifecycle("[validateGuzhenrenEvents] 警告共 ${warnings.size()} 条：")
            warnings.each { logger.lifecycle("  - ${it}") }
        }
        if (!errors.isEmpty()) {
            logger.error("[validateGuzhenrenEvents] 错误共 ${errors.size()} 条：")
            errors.each { logger.error("  - ${it}") }
            throw new GradleException("事件 JSON 校验失败：${errors.size()} 个错误")
        }

        logger.lifecycle("[validateGuzhenrenEvents] 校验通过：共 ${jsonFiles.size()} 个文件，无错误。")
    }
}

// 将 JSON 校验挂接到 check 流水线
tasks.named('check').configure { dependsOn tasks.named('validateGuzhenrenEvents') }

// 将 JSON 校验挂接到编译阶段，确保编译前失败快
tasks.named('compileJava', JavaCompile).configure {
    dependsOn tasks.named('validateGuzhenrenEvents')
}

dependencies {
    // ===== Cloth Config (强依赖，运行必需) =====
    compileOnly "me.shedaniel.cloth:cloth-config-neoforge:${cloth_config_version}"
    runtimeOnly "me.shedaniel.cloth:cloth-config-neoforge:${cloth_config_version}"
    testImplementation "me.shedaniel.cloth:cloth-config-neoforge:${cloth_config_version}"

    // ===== GeckoLib (动画库) =====
    // 主模块按需依赖：编译期与运行期均可用（不打包）
    compileOnly "software.bernie.geckolib:geckolib-neoforge-${geckolib_mc}:${geckolib_version}"
    runtimeOnly  "software.bernie.geckolib:geckolib-neoforge-${geckolib_mc}:${geckolib_version}"
    // 测试环境也提供（供单元测试/运行时类可见）
    testImplementation "software.bernie.geckolib:geckolib-neoforge-${geckolib_mc}:${geckolib_version}"

    // ===== Modern UI (界面框架前置) =====
    compileOnly("icyllis.modernui:ModernUI-Core:${modernui_core_version}") { transitive = false }
    compileOnly("icyllis.modernui:ModernUI-Markflow:${modernui_core_version}") { transitive = false }
    compileOnly("icyllis.modernui:ModernUI-NeoForge:${modernui_version}") { transitive = false }
    runtimeOnly("icyllis.modernui:ModernUI-Core:${modernui_core_version}") { transitive = false }
    runtimeOnly("icyllis.modernui:ModernUI-Markflow:${modernui_core_version}") { transitive = false }
    runtimeOnly("icyllis.modernui:ModernUI-NeoForge:${modernui_version}") { transitive = false }
    testImplementation("icyllis.modernui:ModernUI-NeoForge:${modernui_version}") { transitive = false }
    testRuntimeOnly("icyllis.modernui:ModernUI-Core:${modernui_core_version}") { transitive = false }
    testRuntimeOnly("icyllis.modernui:ModernUI-Markflow:${modernui_core_version}") { transitive = false }

    // 本地 jar（AttributeFix、PlayerAnimator）
    testImplementation files("libs/attributefix-neoforge-1.21.1-21.1.2.jar")
    testImplementation files("libs/player-animation-lib-forge-2.0.1+1.21.1.jar")
    testImplementation files("libs/gzr.jar")
    testImplementation files("libs/Pehkui-3.8.3+1.21-neoforge.jar")

    testImplementation 'com.google.guava:guava:33.3.1-jre'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testImplementation 'org.mockito:mockito-core:5.11.0'
    testImplementation 'org.mockito:mockito-inline:5.2.0'


    annotationProcessor 'org.spongepowered:mixin:0.8.7:processor'

    // ===== Baritone（可选：源码子模块 / 远程坐标 / 本地 Jar） =====
    // 1) 源码子模块：仅编译期可见，避免在常规运行时产生第二个模组
    if (__baritoneProject != null) {
        compileOnly project(":external:Baritone")
        testImplementation project(":external:Baritone")
    }
    // 2) 远程坐标：通过 -Pbaritone_dep=group:artifact:version 指定
    //    例如 -Pbaritone_dep=cabaletta:baritone-api:1.21.1-SNAPSHOT
    if (project.hasProperty('baritone_dep')) {
        implementation project.property('baritone_dep')
        testImplementation project.property('baritone_dep')
    }
    // 3) 本地 Jar：通过 -Pbaritone_local=/path/to/baritone.jar 指定
    if (project.hasProperty('baritone_local')) {
        def jarPath = project.property('baritone_local')
        implementation files(jarPath)
        testImplementation files(jarPath)
    }
}

test {
    useJUnitPlatform()
    classpath += sourceSets.main.runtimeClasspath
}

jacoco {
    toolVersion = '0.8.11'
}

tasks.named('jacocoTestReport', JacocoReport).configure {
    dependsOn tasks.named('test')
    reports {
        xml.required = true
        html.required = true
    }
    classDirectories.setFrom(fileTree(dir: 'build/classes/java/main'))
    sourceDirectories.setFrom(files('src/main/java'))
    executionData.setFrom(fileTree(dir: 'build', includes: [
            'jacoco/test.exec',
            'jacoco/test/*.exec',
            'jacoco/*.exec'
    ]))
}

tasks.named('check').configure { dependsOn tasks.named('jacocoTestReport') }

processResources {
    def replaceProperties = [
            minecraft_version      : minecraft_version,
            minecraft_version_range: minecraft_version_range,
            neo_version            : neo_version,
            neo_version_range      : neo_version_range,
            loader_version_range   : loader_version_range,
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors,
            mod_description        : mod_description
    ]
    inputs.properties replaceProperties

    filesMatching('META-INF/neoforge.mods.toml') {
        expand replaceProperties
    }
}

tasks.named('processResources').configure {
    dependsOn(tasks.named('compileJava'))
}

jar {
    manifest {
        attributes(
                'Specification-Title'   : mod_id,
                'Specification-Vendor'  : mod_group_id,
                'Specification-Version' : '1',
                'Implementation-Title'  : project.name,
                'Implementation-Version': mod_version,
                'Implementation-Vendor' : mod_group_id,
                'MixinConfigs'          : "${mod_id}.mixins.json"
        )
    }
}

// 可选嵌入依赖（Baritone）
configurations { embed }

dependencies {
    // 1) 源码子模块：将产物打包进主 jar，并进行重定位；不引入其依赖（transitive=false），避免把 NeoForge 等塞入
    if (__baritoneProject != null) {
        embed(project(":external:Baritone")) { transitive = false }
    }
    // 2) 本地 Jar 优先
    if (project.hasProperty('baritone_local')) {
        def jarPath = project.property('baritone_local')
        embed files(jarPath)
    } else if (__baritoneLocalDefault.exists()) {
        // 3) 回退到默认 libs 目录下的 jar（存在即自动启用）
        embed files(__baritoneLocalDefault)
    }
    // 4) 远程坐标打包（不建议生产使用）
    if (project.hasProperty('baritone_dep')) {
        embed project.property('baritone_dep')
    }
}

// 当提供 baritone 依赖时，使用 Shadow 产出主 jar 并进行重定位
tasks.named('shadowJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar).configure { sh ->
    def embedConfiguration = project.configurations.embed
    if (__useBaritone) {
        zip64 true
        // 仅打包 embed 里的依赖，避免将 runtimeClasspath（NeoForge 等）塞进主包
        configurations = [embedConfiguration]
        archiveClassifier.set('')
        // 全局排除：避免把 Baritone 作为独立模组入口被识别
        // 1) Baritone 模组入口路径（无论是否重定位，名称模式也排除）
        sh.exclude 'baritone/launch/**'
        sh.exclude 'com/github/cabaletta/baritone/launch/**'
        sh.exclude 'baritone/neoforge/**'
        sh.exclude 'com/github/cabaletta/baritone/neoforge/**'
        sh.exclude 'baritone/forge/**'
        sh.exclude 'com/github/cabaletta/baritone/forge/**'
        // 2) 兜底：直接排除常见入口类名（不管包名如何，包含重定位后的场景）
        sh.exclude '**/BaritoneForgeMod*.class'
        sh.exclude '**/BaritoneMod*.class'
        sh.exclude '**/BaritoneForge*.class'
        // 仅打包 embed 配置里的依赖，避免把运行时所有依赖都塞进来
        from({ embedConfiguration.collect { it.isDirectory() ? it : zipTree(it) } }) {
            // 注意：只在依赖内容里排除 META-INF 与无关资源，保留本模组自己的 META-INF
            exclude 'META-INF/**'
            exclude 'pack.mcmeta'
            exclude 'baritone/launch/**'
            exclude 'com/github/cabaletta/baritone/launch/**'
            exclude 'baritone/neoforge/**'
            exclude 'com/github/cabaletta/baritone/neoforge/**'
            exclude 'baritone/forge/**'
            exclude 'com/github/cabaletta/baritone/forge/**'
            exclude '**/BaritoneForgeMod*.class'
            exclude '**/BaritoneMod*.class'
            exclude '**/BaritoneForge*.class'
        }
        // 复制原 jar 的 manifest（保持 Mixin 配置与 mod 元信息）
        manifest.attributes([
                'Specification-Title'   : mod_id,
                'Specification-Vendor'  : mod_group_id,
                'Specification-Version' : '1',
                'Implementation-Title'  : project.name,
                'Implementation-Version': mod_version,
                'Implementation-Vendor' : mod_group_id,
                'MixinConfigs'          : "${mod_id}.mixins.json"
        ])
        mergeServiceFiles()
        // 重定位（若存在这些包名则生效）
        relocate 'baritone', 'net.tigereye.chestcavity.shadow.baritone'
        relocate 'com.github.cabaletta.baritone', 'net.tigereye.chestcavity.shadow.com.github.cabaletta.baritone'
    } else {
        enabled = false
    }
}

// 启用 shadow 产物替代常规 jar（仅在提供 baritone 依赖时）
tasks.named('jar').configure { it.enabled = !__useBaritone }
tasks.named('assemble').configure { t ->
    if (__useBaritone) {
        dependsOn tasks.named('shadowJar')
    }
}

// 备注：如需改用 Shadow 做重定位，请等待外网插件仓库可用后再切换。

tasks.named('jar').configure { t ->
    if (project.hasProperty('baritone_dep') || project.hasProperty('baritone_local')) {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        from({ project.configurations.embed.collect { it.isDirectory() ? it : zipTree(it) } }) {
            // 避免覆盖 manifest 与签名、及与我们无关的元数据
            exclude 'META-INF/**'
            exclude 'pack.mcmeta'
        }
    }
}

// === Guzhenren ModernUI 文档占位符渲染/还原流程 ===
def pythonExecutable = providers.environmentVariable('PYTHON').orElse('python3')
def guzhenrenDocsScriptFile = layout.projectDirectory.file('scripts/update_guzhenren_docs_values.py').asFile

tasks.register('renderGuzhenrenDocsPlaceholders') {
    group = 'documentation'
    description = '在编译前渲染 ModernUI 文档中的 {VAR} 占位符'
    inputs.file(guzhenrenDocsScriptFile)
    outputs.dir(layout.projectDirectory.dir('build/tmp/guzhenren_docs_placeholder_backup'))
    onlyIf { guzhenrenDocsScriptFile.exists() }
    doLast {
        exec {
            commandLine(
                pythonExecutable.get(),
                guzhenrenDocsScriptFile.absolutePath,
                '--groups', 'human',
                '--render-placeholders',
                '--apply'
            )
        }
    }
}

tasks.register('restoreGuzhenrenDocsPlaceholders') {
    group = 'documentation'
    description = '构建后还原 ModernUI 文档中的占位符'
    inputs.file(guzhenrenDocsScriptFile)
    onlyIf { guzhenrenDocsScriptFile.exists() }
    doLast {
        exec {
            commandLine(
                pythonExecutable.get(),
                guzhenrenDocsScriptFile.absolutePath,
                '--restore-placeholders'
            )
        }
    }
}

tasks.named('compileJava').configure { t ->
    t.dependsOn(tasks.named('renderGuzhenrenDocsPlaceholders'))
    t.finalizedBy(tasks.named('restoreGuzhenrenDocsPlaceholders'))
}


idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}
