# 多重剑影蛊 - 实现计划 v2.0 (修订版)

## ⚠️ 架构变更通知 (2025-11-14重大更新)

**本计划已被器官模式实现替代**

- **原计划**: 基于 `DuochongjianyingGuItem` 物品类实现
- **新设计**: 基于 `DuochongjianyingGuOrganBehavior` 器官行为实现
- **变更日期**: 2025-11-14
- **变更原因**: 统一剑道模块架构，所有蛊虫都通过器官系统实现
- **详细说明**: 参见 [架构重构完成总结.md](架构重构完成总结.md) 和 [架构重构_物品到器官_2025-11-14.md](架构重构_物品到器官_2025-11-14.md)

**本文档保留作为历史参考**，记录了原物品模式的设计思路。以下内容中：
- ✅ **阶段1（实体系统）**: 100%保留有效
- ❌ **阶段2（物品实现）**: 已被器官实现替代
- ✅ **阶段3（UI系统）**: 100%保留有效
- ✅ **阶段4（增益系统）**: 100%保留有效
- ⏸️ **阶段5-6**: 待实施，基于器官模式

---

## 文档元信息
- **创建日期**: 2025-11-14
- **修订日期**: 2025-11-14 (评审后大幅修订 + Capabilities API方案集成 + 架构变更说明)
- **版本**: v2.2 (添加架构变更通知)
- **原版本**: v2.1 (收敛MVP + 完整Capabilities API集成方案)
- **复杂度评级**: ⭐⭐⭐⭐ (从5星降为4星，去除过度设计)
- **估计工作量**: 2-3个开发周期 (从3-5周期收敛)
- **阶段1状态**: ✅ 已完成 (2025-11-14)
- **阶段2状态**: ❌ 已被器官模式替代
- **阶段3状态**: ✅ 已完成 (2025-11-14)
- **阶段4状态**: ✅ 已完成 (2025-11-14)
- **当前阶段**: 阶段5 (AI适配器 - 待开始)

---

## 评审反馈总结

### 识别的关键风险
1. ❌ **ChestCavity快照不存在** - `ChestCavitySnapshot` 类不在代码库中
2. ❌ **物品NBT滥用实体序列化** - 复用 `addAdditionalSaveData` 会导致状态不一致
3. ❌ **跨维度/离线场景未处理** - `getEntity(UUID)` 在未加载区块返回null
4. ❌ **所有权校验缺失** - 他人可利用物品控制分身
5. ❌ **交互不一致** - Shift+右键仅在 `useOn()` 中实现
6. ⚠️ **能力系统实现风险** - ItemHandler 挂载与序列化需对齐API
7. ⚠️ **AI适配器性能** - 每tick执行反编译代码可能较重

### 修订策略 (遵循KISS/YAGNI)
✅ **MVP去除胸腔复制** - 仅镜像皮肤，不影响战斗属性
✅ **专用物品序列化** - 新增 `serializeToItemNBT/deserializeFromItemNBT`
✅ **所有权强制校验** - 物品绑定owner UUID，所有操作校验
✅ **交互一致性** - `use()` 优先处理Shift打开界面
✅ **异常降级机制** - 跨维度/实体丢失时惰性清理+友好提示
✅ **AI分频执行** - 每2-3 tick执行一次，加try/catch防护
✅ **Capabilities API正确集成** (v2.1新增) - 使用 `RegisterCapabilitiesEvent` + `VanillaContainerWrapper` 遵循NeoForge 1.21.1官方模式

---

## 一、需求分析 (收敛版)

### 1.1 MVP核心功能

**多重剑影蛊** (`item.guzhenren.duochongjianying`)
- **主动技能**: 虚实交锋
  - 右键空气：召唤/召回分身
  - Shift+右键：打开分身界面 (如果分身存在)

- **分身特性** (MVP范围):
  - ✅ 复制玩家皮肤
  - ✅ 低一个转数境界 (最低1转1阶段)
  - ✅ 资源系统 (真元/精力/魂魄顶满)
  - ✅ 6+1格物品栏 (6格蛊虫 + 1格增益)
  - ✅ 基础蛊师AI (近战 + 机会释放蛊虫)
  - ❌ ~~胸腔数据复制~~ (延后到第二迭代)

### 1.2 去除/延后的功能

| 功能 | 原计划 | 修订决策 | 理由 |
|------|--------|----------|------|
| 胸腔数据 | ⭐⭐⭐⭐ | 延后至v2 | `ChestCavitySnapshot`不存在，深耦合风险高 |
| 完整AI | ⭐⭐⭐⭐⭐ | 简化为基础版 | 反编译Procedure维护成本高，先验证可行性 |
| 跨维度传送 | ⭐⭐⭐ | 仅提示不可用 | 复杂度高，MVP只处理同维度 |
| 杀招系统 | ⭐⭐⭐ | 延后至v2 | 需要深度理解AI逻辑 |

---

## 二、架构设计 (收敛版)

### 2.1 核心类设计

#### 2.1.1 `PersistentGuCultivatorClone` (核心实体)

**文件位置**:
```
src/main/java/net/tigereye/chestcavity/compat/guzhenren/item/jian_dao/entity/PersistentGuCultivatorClone.java
```

**关键字段**:
```java
public class PersistentGuCultivatorClone extends PathfinderMob {
    // ============ 同步数据 (EntityDataAccessor) ============
    private static final EntityDataAccessor<Optional<UUID>> OWNER =
        SynchedEntityData.defineId(PersistentGuCultivatorClone.class, EntityDataSerializers.OPTIONAL_UUID);
    private static final EntityDataAccessor<String> SKIN_TEXTURE =
        SynchedEntityData.defineId(PersistentGuCultivatorClone.class, EntityDataSerializers.STRING);
    private static final EntityDataAccessor<String> SKIN_MODEL =
        SynchedEntityData.defineId(PersistentGuCultivatorClone.class, EntityDataSerializers.STRING);
    private static final EntityDataAccessor<Integer> SKIN_COLOR =
        SynchedEntityData.defineId(PersistentGuCultivatorClone.class, EntityDataSerializers.INT);

    // ============ 物品栏 (ItemHandler能力) ============
    private final ItemStackHandler inventory = new ItemStackHandler(7) {
        @Override
        protected void onContentsChanged(int slot) {
            // 标记需要保存 + 通知分身更新
            PersistentGuCultivatorClone.this.inventoryChanged = true;
        }

        @Override
        public boolean isItemValid(int slot, @Nonnull ItemStack stack) {
            if (slot < 6) {
                // 槽位0-5: 仅允许蛊虫
                return stack.is(ItemTags.create(ResourceLocation.fromNamespaceAndPath("guzhenren", "guchong")));
            } else {
                // 槽位6: 仅允许增益物品
                return CloneBoostItemRegistry.isBoostItem(stack.getItem());
            }
        }
    };
    private boolean inventoryChanged = false;

    // ============ AI状态 (PersistentData) ============
    // 由 GuCultivatorAIAdapter 管理，字段包括：
    // - "近战": boolean
    // - "蛊虫CD", "蛊虫1CD"..."蛊虫5CD": double
    // - "ai_initialized": boolean (标记是否已初始化)

    // ============ 境界/资源 (PersistentData + GuzhenrenResourceBridge) ============
    // - "野外蛊师转数": double (1-5)
    // - "转数": String ("一转"..."五转")
    // - "野外蛊师阶段": double (1-4)
    // - "阶段": String ("初阶"..."巅峰")
    // - 真元/精力/魂魄: 通过 GuzhenrenResourceBridge 访问
}
```

**核心方法**:

##### ✅ 专用物品序列化方法 (新增)
```java
/**
 * 序列化到物品NBT (仅存储必要字段)
 * 不复用 addAdditionalSaveData，避免状态不一致
 */
public CompoundTag serializeToItemNBT() {
    CompoundTag tag = new CompoundTag();

    // 1. 所有者UUID
    this.entityData.get(OWNER).ifPresent(uuid -> tag.putUUID("OwnerUUID", uuid));

    // 2. 境界数据
    tag.putDouble("Tier", this.getPersistentData().getDouble("野外蛊师转数"));
    tag.putDouble("Stage", this.getPersistentData().getDouble("野外蛊师阶段"));

    // 3. 皮肤数据
    tag.putString("SkinTexture", this.entityData.get(SKIN_TEXTURE));
    tag.putString("SkinModel", this.entityData.get(SKIN_MODEL));
    tag.putInt("SkinColor", this.entityData.get(SKIN_COLOR));

    // 4. 物品栏 (7格)
    CompoundTag inventoryTag = this.inventory.serializeNBT();
    tag.put("Inventory", inventoryTag);

    // 5. 资源快照 (仅当前值，重新召唤时会重新初始化上限)
    try {
        var handle = GuzhenrenResourceBridge.open(this);
        handle.ifPresent(h -> {
            h.getZhenyuan().ifPresent(v -> tag.putDouble("Zhenyuan", v));
            h.getJingli().ifPresent(v -> tag.putDouble("Jingli", v));
            h.read("hunpo").ifPresent(v -> tag.putDouble("Hunpo", v));
        });
    } catch (Exception e) {
        // 静默失败，使用默认值
    }

    return tag;
}

/**
 * 从物品NBT反序列化 (在spawn后调用)
 */
public void deserializeFromItemNBT(CompoundTag tag) {
    // 1. 所有者UUID
    if (tag.hasUUID("OwnerUUID")) {
        this.entityData.set(OWNER, Optional.of(tag.getUUID("OwnerUUID")));
    }

    // 2. 境界数据
    if (tag.contains("Tier") && tag.contains("Stage")) {
        int tier = (int) tag.getDouble("Tier");
        int stage = (int) tag.getDouble("Stage");
        GuCultivatorPersistentUtil.setTierAndStage(this, tier, stage);
    }

    // 3. 皮肤数据
    if (tag.contains("SkinTexture")) {
        this.entityData.set(SKIN_TEXTURE, tag.getString("SkinTexture"));
        this.entityData.set(SKIN_MODEL, tag.getString("SkinModel"));
        this.entityData.set(SKIN_COLOR, tag.getInt("SkinColor"));
    }

    // 4. 物品栏
    if (tag.contains("Inventory")) {
        this.inventory.deserializeNBT(tag.getCompound("Inventory"));
    }

    // 5. 资源快照 (仅恢复当前值，上限已在spawn时初始化)
    try {
        var handle = GuzhenrenResourceBridge.open(this);
        handle.ifPresent(h -> {
            if (tag.contains("Zhenyuan")) h.setZhenyuan(tag.getDouble("Zhenyuan"));
            if (tag.contains("Jingli")) h.setJingli(tag.getDouble("Jingli"));
            if (tag.contains("Hunpo")) h.writeDouble("hunpo", tag.getDouble("Hunpo"));
        });
    } catch (Exception e) {
        // 静默失败
    }
}
```

##### ✅ 能力系统实现 (稳定化)
```java
@Override
public <T> LazyOptional<T> getCapability(Capability<T> cap, @Nullable Direction side) {
    if (cap == Capabilities.ItemHandler.ENTITY) {
        return LazyOptional.of(() -> this.inventory).cast();
    }
    return super.getCapability(cap, side);
}

@Override
public void addAdditionalSaveData(CompoundTag tag) {
    super.addAdditionalSaveData(tag);

    // 持久化所有者UUID
    this.entityData.get(OWNER).ifPresent(uuid -> tag.putUUID("OwnerUUID", uuid));

    // 持久化物品栏 (7格)
    tag.put("Inventory", this.inventory.serializeNBT());

    // 持久化皮肤
    tag.putString("SkinTexture", this.entityData.get(SKIN_TEXTURE));
    tag.putString("SkinModel", this.entityData.get(SKIN_MODEL));
    tag.putInt("SkinColor", this.entityData.get(SKIN_COLOR));

    // 境界/资源由 PersistentData 自动保存
}

@Override
public void readAdditionalSaveData(CompoundTag tag) {
    super.readAdditionalSaveData(tag);

    // 恢复所有者UUID
    if (tag.hasUUID("OwnerUUID")) {
        this.entityData.set(OWNER, Optional.of(tag.getUUID("OwnerUUID")));
    }

    // 恢复物品栏
    if (tag.contains("Inventory")) {
        this.inventory.deserializeNBT(tag.getCompound("Inventory"));
    }

    // 恢复皮肤
    if (tag.contains("SkinTexture")) {
        this.entityData.set(SKIN_TEXTURE, tag.getString("SkinTexture"));
        this.entityData.set(SKIN_MODEL, tag.getString("SkinModel"));
        this.entityData.set(SKIN_COLOR, tag.getInt("SkinColor"));
    }
}
```

##### ✅ AI tick优化 (分频执行)
```java
private int aiTickCounter = 0; // AI分频计数器

@Override
public void baseTick() {
    super.baseTick();

    if (!this.level().isClientSide) {
        // 初始化AI数据 (首次运行)
        if (!getPersistentData().contains("ai_initialized")) {
            try {
                GuCultivatorAIAdapter.initializeAIData(this);
                getPersistentData().putBoolean("ai_initialized", true);
            } catch (Exception e) {
                // 初始化失败也标记已尝试，避免循环
                getPersistentData().putBoolean("ai_initialized", true);
            }
        }

        // 每3 tick执行一次AI逻辑 (降低性能开销)
        if (++aiTickCounter >= 3) {
            aiTickCounter = 0;
            try {
                Object cap = this.getCapability(Capabilities.ItemHandler.ENTITY, null);
                if (cap instanceof IItemHandlerModifiable handler) {
                    GuCultivatorAIAdapter.tickGuUsage(this, handler);
                }
            } catch (Exception e) {
                // 静默失败，记录日志
                ChestCavity.LOGGER.warn("分身AI执行失败: {}", e.getMessage());
            }
        }
    }
}
```

##### ✅ 所有权校验方法
```java
/**
 * 检查指定玩家是否拥有该分身
 */
public boolean isOwnedBy(Player player) {
    Optional<UUID> ownerOpt = this.entityData.get(OWNER);
    return ownerOpt.isPresent() && ownerOpt.get().equals(player.getUUID());
}

/**
 * 打开物品栏界面 (带所有权校验)
 */
public void openInventoryMenu(ServerPlayer player) {
    if (!isOwnedBy(player)) {
        player.displayClientMessage(Component.literal("§c这不是你的分身！"), true);
        return;
    }

    player.openMenu(new SimpleMenuProvider(
        (id, playerInv, p) -> new CloneInventoryMenu(id, playerInv, this),
        Component.literal("分身物品栏")
    ));
}
```

##### ✅ 静态工厂方法 (简化版)
```java
/**
 * 召唤新分身
 */
public static PersistentGuCultivatorClone spawn(
    ServerLevel level,
    Player owner,
    Vec3 position
) {
    // 1. 读取玩家转数
    int playerTier = 1;
    try {
        var handle = GuzhenrenResourceBridge.open(owner);
        if (handle.isPresent()) {
            playerTier = (int) Math.round(handle.get().getZhuanshu().orElse(1.0));
        }
    } catch (Exception e) {
        // 使用默认值
    }

    // 2. 计算分身境界: 玩家转数 - 1 (最低1转1阶段)
    int cloneTier = Math.max(1, playerTier - 1);
    int cloneStage = 1; // 初阶

    // 3. 创建实体
    PersistentGuCultivatorClone clone = CCEntities.PERSISTENT_GU_CULTIVATOR_CLONE.get().create(level);
    if (clone == null) return null;

    clone.moveTo(position.x, position.y, position.z, owner.getYRot(), 0.0f);
    clone.setOwner(owner);

    // 4. 设置皮肤
    PlayerSkinUtil.SkinSnapshot skin = PlayerSkinUtil.SkinSnapshot.from(owner);
    clone.setSkin(skin);

    // 5. 设置境界
    GuCultivatorPersistentUtil.setTierAndStage(clone, cloneTier, cloneStage);

    // 6. 初始化资源 (基于转数)
    initializeResources(clone, cloneTier);

    // 7. 调用原生初始化 (触发模组AI钩子)
    try {
        if (clone instanceof Mob mob) {
            var diff = level.getCurrentDifficultyAt(mob.blockPosition());
            mob.finalizeSpawn(level, diff, MobSpawnType.MOB_SUMMONED, null);
        }
    } catch (Exception e) {
        ChestCavity.LOGGER.warn("finalizeSpawn失败: {}", e.getMessage());
    }

    level.addFreshEntity(clone);
    return clone;
}

/**
 * 初始化资源上限并顶满
 */
private static void initializeResources(PersistentGuCultivatorClone clone, int tier) {
    try {
        var handle = GuzhenrenResourceBridge.open(clone);
        if (handle.isEmpty()) return;

        var h = handle.get();

        // 资源上限 (简化公式)
        double zhenyuanMax = tier * 200.0;
        double jingliMax = tier * 100.0;
        double hunpoMax = tier * 50.0;

        h.setMaxZhenyuan(zhenyuanMax);
        h.setZhenyuan(zhenyuanMax);

        h.setMaxJingli(jingliMax);
        h.setJingli(jingliMax);

        h.writeDouble("zuida_hunpo", hunpoMax);
        h.writeDouble("hunpo", hunpoMax);

    } catch (Exception e) {
        // 静默失败
    }
}

private void setSkin(PlayerSkinUtil.SkinSnapshot snapshot) {
    // 同步到客户端
    int argb = ((int) (snapshot.alpha() * 255) & 0xFF) << 24
             | ((int) (snapshot.red() * 255) & 0xFF) << 16
             | ((int) (snapshot.green() * 255) & 0xFF) << 8
             | ((int) (snapshot.blue() * 255) & 0xFF);

    this.entityData.set(SKIN_COLOR, argb);
    this.entityData.set(SKIN_TEXTURE, snapshot.texture().toString());
    this.entityData.set(SKIN_MODEL, snapshot.model());
}

private void setOwner(Player owner) {
    this.entityData.set(OWNER, Optional.of(owner.getUUID()));
}
```

##### ✅ 死亡时清理物品状态
```java
@Override
public void die(DamageSource source) {
    super.die(source);

    // 查找持有该分身的玩家并清理物品NBT
    LivingEntity owner = getOwnerEntity();
    if (owner instanceof Player player) {
        // 遍历玩家所有物品栏
        for (ItemStack stack : player.getInventory().items) {
            if (stack.getItem() instanceof DuochongjianyingGuItem) {
                if (stack.hasTag() && stack.getTag().hasUUID("CloneUUID")) {
                    UUID storedUUID = stack.getTag().getUUID("CloneUUID");
                    if (storedUUID.equals(this.getUUID())) {
                        // 清理状态
                        stack.getTag().remove("CloneUUID");
                        stack.getTag().remove("CloneData");
                        stack.getTag().remove("DimensionKey");

                        player.displayClientMessage(
                            Component.literal("§c你的分身已阵亡！"),
                            true
                        );
                        break;
                    }
                }
            }
        }
    }
}

@Nullable
private LivingEntity getOwnerEntity() {
    if (!(this.level() instanceof ServerLevel server)) {
        return null;
    }
    Optional<UUID> ownerId = this.entityData.get(OWNER);
    return ownerId
        .map(server::getEntity)
        .filter(e -> e instanceof LivingEntity)
        .map(e -> (LivingEntity) e)
        .orElse(null);
}
```

---

#### 2.1.2 `DuochongjianyingGuItem` (物品类)

**核心逻辑修订**:

##### ✅ 交互一致性 (use()优先处理Shift)
```java
@Override
public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand hand) {
    ItemStack stack = player.getItemInHand(hand);

    if (level.isClientSide) {
        return InteractionResultHolder.success(stack);
    }

    ServerLevel serverLevel = (ServerLevel) level;

    // ========== 优先处理: Shift + 右键 = 打开界面 ==========
    if (player.isShiftKeyDown()) {
        return handleOpenInventory(serverLevel, player, stack);
    }

    // ========== 非Shift: 召唤/召回分身 ==========
    return handleSummonOrRecall(serverLevel, player, stack);
}

/**
 * 处理打开分身界面
 */
private InteractionResultHolder<ItemStack> handleOpenInventory(
    ServerLevel level,
    Player player,
    ItemStack stack
) {
    // 1. 所有权校验
    if (!isOwnedBy(stack, player)) {
        player.displayClientMessage(Component.literal("§c这不是你的蛊虫！"), true);
        return InteractionResultHolder.fail(stack);
    }

    // 2. 检查分身是否存在
    if (!stack.hasTag() || !stack.getTag().hasUUID("CloneUUID")) {
        player.displayClientMessage(Component.literal("§7分身未召唤"), true);
        return InteractionResultHolder.fail(stack);
    }

    UUID cloneUUID = stack.getTag().getUUID("CloneUUID");
    Entity entity = level.getEntity(cloneUUID);

    if (entity instanceof PersistentGuCultivatorClone clone && clone.isAlive()) {
        // 打开界面
        if (player instanceof ServerPlayer serverPlayer) {
            clone.openInventoryMenu(serverPlayer);
        }
        return InteractionResultHolder.consume(stack);
    } else {
        // 分身不存在/已死亡，惰性清理
        cleanupCloneData(stack);
        player.displayClientMessage(Component.literal("§c分身已失效"), true);
        return InteractionResultHolder.fail(stack);
    }
}

/**
 * 处理召唤/召回分身
 */
private InteractionResultHolder<ItemStack> handleSummonOrRecall(
    ServerLevel level,
    Player player,
    ItemStack stack
) {
    // 1. 所有权校验
    if (!isOwnedBy(stack, player)) {
        player.displayClientMessage(Component.literal("§c这不是你的蛊虫！"), true);
        return InteractionResultHolder.fail(stack);
    }

    // 2. 检查是否已有分身存在
    if (stack.hasTag() && stack.getTag().hasUUID("CloneUUID")) {
        UUID cloneUUID = stack.getTag().getUUID("CloneUUID");

        // ========== 跨维度检查 ==========
        String dimensionKey = stack.getTag().getString("DimensionKey");
        String currentDimensionKey = level.dimension().location().toString();

        if (!dimensionKey.equals(currentDimensionKey)) {
            player.displayClientMessage(
                Component.literal("§c分身在不同维度，无法召回！"),
                true
            );
            return InteractionResultHolder.fail(stack);
        }

        Entity entity = level.getEntity(cloneUUID);

        if (entity instanceof PersistentGuCultivatorClone clone && clone.isAlive()) {
            // ========== 召回分身 ==========
            recallClone(stack, clone, player);
            return InteractionResultHolder.consume(stack);
        } else {
            // 实体不存在或已死亡，惰性清理
            cleanupCloneData(stack);
        }
    }

    // ========== 召唤分身 ==========
    PersistentGuCultivatorClone clone = summonClone(level, player, stack);
    if (clone != null) {
        // 保存分身UUID和维度
        stack.getOrCreateTag().putUUID("CloneUUID", clone.getUUID());
        stack.getTag().putString("DimensionKey", level.dimension().location().toString());

        player.displayClientMessage(Component.literal("§a分身已召唤"), true);

        // 播放召唤特效
        level.playSound(null, player.blockPosition(),
            SoundEvents.ENDER_DRAGON_FLAP, SoundSource.PLAYERS, 1.0f, 1.2f);

        return InteractionResultHolder.consume(stack);
    }

    return InteractionResultHolder.fail(stack);
}

/**
 * 召唤分身
 */
private PersistentGuCultivatorClone summonClone(
    ServerLevel level,
    Player player,
    ItemStack stack
) {
    Vec3 spawnPos = player.position().add(player.getLookAngle().scale(2.0));

    // 创建新分身
    PersistentGuCultivatorClone clone = PersistentGuCultivatorClone.spawn(
        level,
        player,
        spawnPos
    );

    if (clone == null) return null;

    // 如果物品NBT中有存储的数据，恢复它
    if (stack.hasTag() && stack.getTag().contains("CloneData")) {
        CompoundTag cloneData = stack.getTag().getCompound("CloneData");
        clone.deserializeFromItemNBT(cloneData); // 使用专用方法
    }

    return clone;
}

/**
 * 召回分身
 */
private void recallClone(
    ItemStack stack,
    PersistentGuCultivatorClone clone,
    Player player
) {
    // 1. 保存分身数据到物品NBT (使用专用方法)
    CompoundTag cloneData = clone.serializeToItemNBT();
    stack.getOrCreateTag().put("CloneData", cloneData);

    // 2. 移除分身实体
    clone.discard();

    // 3. 清除UUID (因为实体已不存在)
    stack.getTag().remove("CloneUUID");
    stack.getTag().remove("DimensionKey");

    // 4. 播放召回特效
    clone.level().playSound(null, clone.blockPosition(),
        SoundEvents.ENDERMAN_TELEPORT, SoundSource.PLAYERS, 1.0f, 1.2f);

    player.displayClientMessage(Component.literal("§6分身已召回"), true);
}

/**
 * 惰性清理分身数据
 */
private void cleanupCloneData(ItemStack stack) {
    if (stack.hasTag()) {
        stack.getTag().remove("CloneUUID");
        stack.getTag().remove("CloneData");
        stack.getTag().remove("DimensionKey");
    }
}

/**
 * 所有权校验 (物品绑定检查)
 */
private boolean isOwnedBy(ItemStack stack, Player player) {
    // 如果物品没有绑定所有者，首次使用时绑定
    if (!stack.hasTag() || !stack.getTag().hasUUID("OwnerUUID")) {
        stack.getOrCreateTag().putUUID("OwnerUUID", player.getUUID());
        return true;
    }

    UUID ownerUUID = stack.getTag().getUUID("OwnerUUID");
    return ownerUUID.equals(player.getUUID());
}
```

##### ✅ 去除 `useOn()` 中的重复逻辑
```java
@Override
public InteractionResult useOn(UseOnContext context) {
    // 所有交互都在 use() 中处理，useOn() 不做特殊处理
    return InteractionResult.PASS;
}
```

---

#### 2.1.3 `GuCultivatorAIAdapter` (AI适配器)

**简化版实现** (MVP仅支持基础蛊虫释放):

```java
public final class GuCultivatorAIAdapter {

    /**
     * 初始化AI所需的 PersistentData 键
     */
    public static void initializeAIData(LivingEntity entity) {
        var tag = entity.getPersistentData();

        // 近战模式标记
        tag.putBoolean("近战", false);

        // 蛊虫冷却 (全部初始化为0)
        tag.putDouble("蛊虫CD", 0.0);
        for (int i = 1; i <= 5; i++) {
            tag.putDouble("蛊虫" + i + "CD", 0.0);
        }

        // 杀招冷却 (初始延迟10秒，MVP阶段不实现杀招)
        tag.putDouble("杀招CD", 200.0);
    }

    /**
     * 每3 tick执行一次的蛊虫释放逻辑
     */
    public static void tickGuUsage(LivingEntity entity, IItemHandlerModifiable handler) {
        if (!(entity instanceof Mob mob)) return;

        LivingEntity target = mob.getTarget();
        if (target == null) return;

        var tag = entity.getPersistentData();

        // ========== 冷却递减 ==========
        tag.putDouble("蛊虫CD", tag.getDouble("蛊虫CD") - 3.0); // 因为每3 tick执行一次
        for (int i = 1; i <= 5; i++) {
            String cdKey = "蛊虫" + i + "CD";
            tag.putDouble(cdKey, tag.getDouble(cdKey) - 3.0);
        }

        // ========== 尝试释放蛊虫 (全局CD控制) ==========
        if (tag.getDouble("蛊虫CD") <= 0.0) {
            // 遍历6个槽位，找到第一个冷却完毕的蛊虫
            for (int slot = 0; slot < 6; slot++) {
                String cdKey = slot == 0 ? "蛊虫CD" : "蛊虫" + slot + "CD";

                if (tag.getDouble(cdKey) <= 0.0) {
                    ItemStack guStack = handler.getStackInSlot(slot);

                    if (!guStack.isEmpty()) {
                        // 执行释放逻辑 (模拟 GuShiGuChong1Procedure)
                        releaseGu(entity, guStack);

                        // 设置冷却 (简化版: 固定5秒)
                        tag.putDouble(cdKey, 100.0);
                        tag.putDouble("蛊虫CD", 20.0); // 全局1秒CD
                        break; // 每次只释放一个
                    }
                }
            }
        }
    }

    /**
     * 释放蛊虫 (放主手 → swing → 清空)
     */
    private static void releaseGu(LivingEntity entity, ItemStack guStack) {
        try {
            // 1. 放入主手
            ItemStack copy = guStack.copy();
            copy.setCount(1);
            entity.setItemInHand(InteractionHand.MAIN_HAND, copy);

            // 2. 挥动手臂 (触发物品使用逻辑)
            entity.swing(InteractionHand.MAIN_HAND, true);

            // 3. 清空主手 (避免持久占用)
            entity.setItemInHand(InteractionHand.MAIN_HAND, ItemStack.EMPTY);

        } catch (Exception e) {
            // 释放失败也不要崩溃
        }
    }
}
```

---

## 三、实施清单 (MVP范围)

### 阶段1: 核心实体开发 ✅ **已完成** (2025-11-14)

#### 1.1 创建 `PersistentGuCultivatorClone.java`
- [x] 定义 EntityDataAccessor (OWNER, SKIN_*)
- [x] 实现 ItemStackHandler(7) 与能力系统
- [x] 实现 `serializeToItemNBT` / `deserializeFromItemNBT`
- [x] 实现 `addAdditionalSaveData` / `readAdditionalSaveData`
- [x] 实现 `baseTick()` (分频AI调用)
- [x] 实现 `spawn()` 静态工厂方法
- [x] 实现 `isOwnedBy()` / `openInventoryMenu()`
- [x] 实现 `die()` (清理物品状态)
- [x] 注册 AI Goals (参考 `NanGuXiuEntity`)
- [x] 提供 `getInventory()` 公共访问方法 (Capabilities API临时方案)

#### 1.2 注册实体
- [x] 在 `CCEntities.java` 中注册 `PERSISTENT_GU_CULTIVATOR_CLONE`
- [x] 配置属性 (血量、速度、攻击力)
- [x] 创建渲染器 `PersistentGuCultivatorCloneRenderer.java` (复用 `SwordShadowCloneRenderer` 逻辑)

**验收报告**: 参见 `阶段1验收报告.md`
**已知问题**: Capabilities API 支持推迟到阶段3 (Entity.getCapability() 在 NeoForge 1.21.1 为 final 方法)

### 阶段2: 物品与交互 (3天)

#### 2.1 创建 `DuochongjianyingGuItem.java`
- [ ] 实现 `use()` (Shift优先打开界面)
- [ ] 实现 `handleOpenInventory()`
- [ ] 实现 `handleSummonOrRecall()`
- [ ] 实现 `summonClone()` / `recallClone()`
- [ ] 实现 `cleanupCloneData()` (惰性清理)
- [ ] 实现 `isOwnedBy()` (所有权校验)

#### 2.2 注册物品
- [ ] 在 `CCItems.java` 中注册物品
- [ ] 配置物品属性 (最大堆叠数=1, 稀有度)
- [ ] 添加本地化字符串 (zh_cn.json)

### 阶段3: 界面系统 + Capabilities API (5天)

#### 3.0 实现 Capabilities API 集成 ⭐ **新增**
**参考文档**: `Capabilities_API集成方案.md`

- [ ] **3.0.1** 在 `PersistentGuCultivatorClone.java` 添加 `getContainerView()` 方法
  - 创建 `SimpleContainer` 适配器 (~50行)
  - 桥接 `ItemStackHandler` 到原版 `Container` 接口
  - 实现 `stillValid()` 进行所有权校验

- [ ] **3.0.2** 在 `ChestCavity.java` 添加能力注册
  - 添加 `registerCapabilities(RegisterCapabilitiesEvent event)` 方法 (~15行)
  - 在构造函数中添加监听器: `bus.addListener(this::registerCapabilities);`
  - 使用 `VanillaContainerWrapper.of()` 包装 `getContainerView()`

- [ ] **3.0.3** 测试能力访问
  - 验证 `entity.getCapability(Capabilities.Item.ENTITY, null)` 返回非null
  - 验证返回类型为 `ResourceHandler<ItemResource>`
  - 验证外部代码可以通过Capability API访问物品栏

**实施细节**:
```java
// 在 PersistentGuCultivatorClone.java 中添加
public net.minecraft.world.Container getContainerView() {
    return new net.minecraft.world.SimpleContainer(inventory.getSlots()) {
        @Override
        public ItemStack getItem(int slot) {
            return inventory.getStackInSlot(slot);
        }

        @Override
        public void setItem(int slot, ItemStack stack) {
            inventory.setStackInSlot(slot, stack);
        }

        @Override
        public boolean stillValid(Player player) {
            return PersistentGuCultivatorClone.this.isOwnedBy(player);
        }

        // ... 实现其他必需方法
    };
}

// 在 ChestCavity.java 中添加
private void registerCapabilities(RegisterCapabilitiesEvent event) {
    event.registerEntity(
        Capabilities.Item.ENTITY,
        CCEntities.PERSISTENT_GU_CULTIVATOR_CLONE.get(),
        (entity, context) -> {
            if (entity instanceof PersistentGuCultivatorClone clone) {
                return VanillaContainerWrapper.of(clone.getContainerView());
            }
            return null;
        }
    );
}
```

#### 3.1 创建 `CloneInventoryMenu.java`
- [ ] 定义7个槽位 (6蛊虫 + 1增益)
- [ ] 实现槽位过滤 (Tag: guzhenren:guchong)
- [ ] 实现增益槽位监听 (`onContentsChanged`)
- [ ] 添加玩家背包槽位

#### 3.2 创建 `CloneInventoryScreen.java` (客户端)
- [ ] 设计GUI纹理 (7槽位布局)
- [ ] 实现渲染逻辑
- [ ] 绑定 Menu 与 Screen

#### 3.3 注册容器
- [ ] 在 `CCContainers.java` 中注册 `CLONE_INVENTORY_MENU`
- [ ] 在客户端事件中绑定 Screen

### 阶段4: 增益系统 (2天)

#### 4.1 创建 `CloneBoostItemRegistry.java`
- [ ] 定义 `ICloneBoostEffect` 接口
- [ ] 实现 `register()` / `isBoostItem()` / `getBoostEffect()`
- [ ] 添加示例增益物品 (钻石、凋零骷髅头)

#### 4.2 集成到 Menu
- [ ] 槽位6的 `setChanged()` 调用 `applyBoostEffect()`

### 阶段5: AI适配器 (2天)

#### 5.1 创建 `GuCultivatorAIAdapter.java`
- [ ] 实现 `initializeAIData()`
- [ ] 实现 `tickGuUsage()` (简化版)
- [ ] 实现 `releaseGu()` (放主手逻辑)

### 阶段6: 测试与修复 (3天)

#### 6.1 单元测试
- [ ] 测试境界计算 (1转→1转, 3转→2转)
- [ ] 测试资源初始化
- [ ] 测试物品NBT序列化

#### 6.2 集成测试
- [ ] 测试召唤/召回流程
- [ ] 测试界面打开与物品放入
- [ ] 测试分身AI (近战 + 蛊虫释放)
- [ ] 测试所有权校验
- [ ] 测试跨维度提示
- [ ] 测试分身死亡清理

#### 6.3 边界测试
- [ ] 分身死亡后重新召唤
- [ ] 实体UUID悬挂 (惰性清理)
- [ ] 他人尝试使用物品
- [ ] 快速召唤/召回 (防抖)

---

## 四、关键风险缓解措施

### 4.1 ChestCavity集成 (延后)
- ✅ MVP阶段**完全不涉及**胸腔数据
- 第二迭代若需集成，先提供"只读快照"接口，不影响战斗属性

### 4.2 跨维度场景
- ✅ 物品NBT记录 `DimensionKey`
- ✅ 召回时检查维度一致性，不一致则提示 `§c分身在不同维度，无法召回！`
- 后续版本可增加"跨维度传送"功能 (消耗资源)

### 4.3 离线/区块卸载
- ✅ 分身实体使用常规持久化机制 (区块卸载时保存)
- ✅ 惰性清理：下次使用物品时检测实体是否存在，不存在则清理

### 4.4 所有权绕过
- ✅ 物品绑定 `OwnerUUID` (首次使用时绑定)
- ✅ 所有操作 (召唤/召回/打开界面) 强制校验
- ✅ 分身实体也存储 `OWNER` EntityDataAccessor

### 4.5 AI性能
- ✅ 每3 tick执行一次 (从20 tick/s降为6.67次/s)
- ✅ try/catch包裹，防止崩溃
- ✅ MVP阶段只实现基础释放，不集成完整Procedure

### 4.6 NBT体积控制
- ✅ `serializeToItemNBT` 仅存储：
  - UUID (16字节)
  - 境界 (2个double)
  - 皮肤 (字符串 + int)
  - 物品栏 (7个槽位)
  - 资源快照 (3个double)
- 总体积 < 1KB

---

## 五、后续迭代计划

### 第二迭代 (v2.0)
- [ ] 胸腔数据只读快照 (展示用途)
- [ ] 完整AI集成 (杀招系统)
- [ ] 跨维度传送 (消耗资源)
- [ ] 多分身支持 (配置上限)

### 第三迭代 (v3.0)
- [ ] 分身指令系统 (`/clone follow` 等)
- [ ] 分身技能树 (通过道痕解锁)
- [ ] 分身外观定制

---

## 六、验收标准 (MVP)

### 功能性
- ✅ 右键召唤分身，再次右键召回
- ✅ Shift+右键打开分身界面
- ✅ 分身攻击敌对生物
- ✅ 分身释放蛊虫 (从6格槽位)
- ✅ 增益物品生效 (槽位6)
- ✅ 分身境界 = 玩家境界 - 1
- ✅ 分身复制玩家皮肤
- ✅ 分身死亡后物品状态清理

### 稳定性
- ✅ 无崩溃 (AI异常、序列化错误)
- ✅ 跨维度提示正确
- ✅ 所有权校验生效
- ✅ 惰性清理正常工作

### 性能
- ✅ AI执行不卡服 (3 tick分频)
- ✅ NBT体积合理 (< 1KB)

---

**文档版本**: v2.0 (修订版)
**最后更新**: 2025-11-14
**评审状态**: ✅ 已收敛MVP范围，修正所有高优先级纰漏
**作者**: AI Assistant + Kizunad
